/*

This is an example implementation of a Frugal plugin.

Plugins are used to augment code-generation behavior in Frugal by exposing
various "behavior hooks" (described below) which can be implemented.
Currently, they are only supported by Java.

If a behavior hook is implemented in a loaded plugin, Frugal will call it to
supplement or replace the default behavior (depending on the hook). Note that
if plugins are used, it is the user's responsibility to ensure the plugin
generates valid/compilable code and that Frugal's compatibility with other
languages is not violated. As such, plugins should only be used to enhance
code generated by Frugal and not affect wire-level compatibility.

Since multiple plugins can be provided, some behavior hooks may be called
more than once. Hooks which can only be called once are documented. If
multiple plugins implement these hooks, precedence is determined by the
order in which the plugins are provided. For example, if plugins A, B, and C
all implement the GenerateEnumValue hook, only A's will be invoked.

Frugal plugins are implemented as dynamically linked libraries and supported
in Go 1.8 and above. Note that the same version of Go used to build Frugal
must be used to build the plugin. Plugins are built as follows:

$ go build -buildmode=plugin java_plugin.go

Plugins are then loaded using the "plugins" generator option:

$ frugal -gen java:plugins=java_plugin.so my_idl.frugal

Supported Behavior Hooks (Java):

// GenerateEnumFields is called when generating enum fields, e.g.
//
// private final int value; // produced by a call to GenerateEnumFields
//
// Note that Frugal requires the int value for wire-level compatibility.
GenerateEnumFields(enum *parser.Enum) ([]java.Field, error)

// GenerateEnumConstructors is called when generating enum constructors, e.g.
//
// MyEnum(int value) {      // produced by
//     this.value = value;  // a call to
// }                        // GenerateEnumConstructors
//
// Note that Frugal requires the int value for wire-level compatibility.
GenerateEnumConstructors(enum *parser.Enum) ([]java.EnumConstructor, error)

// GenerateEnumValue is called when generating enum values, e.g.
//
// public enum MyEnum implements TEnum {
//     FOO(1), // produced by a call to GenerateEnumValue
//     BAR(2),
//     BAZ(3);
//
//     ...
//
// If multiple plugins implement this hook, only one will be invoked. Note that
// Frugal requires the int value for wire-level compatibility.
GenerateEnumValue(*parser.Enum, *parser.EnumValue) (java.EnumValue, error)

// GenerateEnumMethods is called when generating enum methods, e.g.
//
// public int getValue() {
//     return value;
// }
//
// Note that Frugal requires the int value for wire-level compatibility.
GenerateEnumMethods(enum *parser.Enum) ([]java.Method, error)

*/
package main

import (
	"fmt"
	"strconv"

	"github.com/Workiva/frugal/compiler/generator"
	"github.com/Workiva/frugal/compiler/generator/java"
	"github.com/Workiva/frugal/compiler/parser"
)

func GenerateEnumFields(enum *parser.Enum) ([]java.Field, error) {
	// private String foo
	field := java.Field{Modifier: "private", Type: "String", Name: "foo"}
	return []java.Field{field}, nil
}

func GenerateEnumConstructors(enum *parser.Enum) ([]java.EnumConstructor, error) {
	// public MyEnum(int value, String foo) {
	//     this.foo = foo;
	//     this.value = value;
	// }
	printer := new(generator.Printer)
	printer.Println("this.foo = foo;")
	printer.Println("this.value = value;")
	constructor := java.EnumConstructor{
		Modifier: "public",
		Arguments: []java.Argument{
			java.Argument{Type: "int", Name: "value"},
			java.Argument{Type: "String", Name: "foo"},
		},
		Body: printer,
	}
	return []java.EnumConstructor{constructor}, nil
}

func GenerateEnumValue(enum *parser.Enum, value *parser.EnumValue) (java.EnumValue, error) {
	// FOO(1, "FOO"), BAR(2, "BAR"), BAZ(3, "BAZ"), etc.
	return java.EnumValue{
		Name:      value.Name,
		Arguments: []string{strconv.Itoa(value.Value), fmt.Sprintf("\"%s\"", value.Name)},
	}, nil
}

func GenerateEnumMethods(enum *parser.Enum) ([]java.Method, error) {
	// public String getFoo() {
	//     return foo;
	// }
	printer := new(generator.Printer)
	printer.Println("return foo;")
	method := java.Method{
		Modifier:   "public",
		ReturnType: "String",
		Name:       "getFoo",
		Body:       printer,
	}
	return []java.Method{method}, nil
}
