// Autogenerated by Frugal Compiler (1.20.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

library variety.src.f_foo_scope;

import 'dart:async';

import 'dart:typed_data' show Uint8List;
import 'package:thrift/thrift.dart' as thrift;
import 'package:frugal/frugal.dart' as frugal;

import 'package:actual_base_dart/actual_base_dart.dart' as t_actual_base_dart;
import 'package:variety/variety.dart' as t_variety;
import 'f_foo_structs.dart' as t_foo_file;


/// This is a thrift service. Frugal will generate bindings that include
/// a frugal Context for each service call.
abstract class FFoo extends t_actual_base_dart.FBaseFoo {

  /// Ping the server.
  Future ping(frugal.FContext ctx);

  /// Blah the server.
  Future<int> blah(frugal.FContext ctx, int num, String str, t_variety.Event event);

  /// oneway methods don't receive a response from the server.
  Future oneWay(frugal.FContext ctx, int id, Map<int, String> req);

  Future<Uint8List> bin_method(frugal.FContext ctx, Uint8List bin, String str);

  Future<int> param_modifiers(frugal.FContext ctx, int opt_num, int default_num, int req_num);

  Future<List<int>> underlying_types_test(frugal.FContext ctx, List<int> list_type, Set<int> set_type);
}

/// This is a thrift service. Frugal will generate bindings that include
/// a frugal Context for each service call.
class FFooClient extends t_actual_base_dart.FBaseFooClient implements FFoo {
  Map<String, frugal.FMethod> _methods;

  FFooClient(frugal.FTransport transport, frugal.FProtocolFactory protocolFactory, [List<frugal.Middleware> middleware])
      : super(transport, protocolFactory) {
    _transport = transport;
    _transport.setRegistry(new frugal.FClientRegistry());
    _protocolFactory = protocolFactory;
    _oprot = _protocolFactory.getProtocol(_transport);

    this._methods = {};
    this._methods['ping'] = new frugal.FMethod(this._ping, 'Foo', 'ping', middleware);
    this._methods['blah'] = new frugal.FMethod(this._blah, 'Foo', 'blah', middleware);
    this._methods['oneWay'] = new frugal.FMethod(this._oneWay, 'Foo', 'oneWay', middleware);
    this._methods['bin_method'] = new frugal.FMethod(this._bin_method, 'Foo', 'bin_method', middleware);
    this._methods['param_modifiers'] = new frugal.FMethod(this._param_modifiers, 'Foo', 'param_modifiers', middleware);
    this._methods['underlying_types_test'] = new frugal.FMethod(this._underlying_types_test, 'Foo', 'underlying_types_test', middleware);
  }

  frugal.FTransport _transport;
  frugal.FProtocolFactory _protocolFactory;
  frugal.FProtocol _oprot;
  frugal.FProtocol get oprot => _oprot;

  /// Ping the server.
  Future ping(frugal.FContext ctx) {
    return this._methods['ping']([ctx]);
  }

  Future _ping(frugal.FContext ctx) async {
    var controller = new StreamController();
    var closeSubscription = _transport.onClose.listen((_) {
      controller.addError(new thrift.TTransportError(
        thrift.TTransportErrorType.NOT_OPEN,
        "Transport closed before request completed."));
      });
    _transport.register(ctx, _recvPingHandler(ctx, controller));
    await writeLock.lock();
    try {
      try {
        oprot.writeRequestHeader(ctx);
        oprot.writeMessageBegin(new thrift.TMessage("ping", thrift.TMessageType.CALL, 0));
        t_foo_file.ping_args args = new t_foo_file.ping_args();
        args.write(oprot);
        oprot.writeMessageEnd();
        await oprot.transport.flush();
      } finally {
        writeLock.unlock();
      }

      return await controller.stream.first.timeout(ctx.timeout);
    } finally {
      closeSubscription.cancel();
      _transport.unregister(ctx);
    }
  }

  _recvPingHandler(frugal.FContext ctx, StreamController controller) {
    pingCallback(thrift.TTransport transport) {
      try {
        var iprot = _protocolFactory.getProtocol(transport);
        iprot.readResponseHeader(ctx);
        thrift.TMessage msg = iprot.readMessageBegin();
        if (msg.type == thrift.TMessageType.EXCEPTION) {
          thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
          iprot.readMessageEnd();
          if (error.type == frugal.FTransport.RESPONSE_TOO_LARGE) {
            controller.addError(new frugal.FMessageSizeError.response());
            return;
          }
          if (error.type == frugal.FRateLimitError.RATE_LIMIT_EXCEEDED) {
            controller.addError(new frugal.FRateLimitError());
            return;
          }
          throw error;
        }

        t_foo_file.ping_result result = new t_foo_file.ping_result();
        result.read(iprot);
        iprot.readMessageEnd();
        controller.add(null);
      } catch(e) {
        controller.addError(e);
        rethrow;
      }
    }
    return pingCallback;
  }

  /// Blah the server.
  Future<int> blah(frugal.FContext ctx, int num, String str, t_variety.Event event) {
    return this._methods['blah']([ctx, num, str, event]);
  }

  Future<int> _blah(frugal.FContext ctx, int num, String str, t_variety.Event event) async {
    var controller = new StreamController();
    var closeSubscription = _transport.onClose.listen((_) {
      controller.addError(new thrift.TTransportError(
        thrift.TTransportErrorType.NOT_OPEN,
        "Transport closed before request completed."));
      });
    _transport.register(ctx, _recvBlahHandler(ctx, controller));
    await writeLock.lock();
    try {
      try {
        oprot.writeRequestHeader(ctx);
        oprot.writeMessageBegin(new thrift.TMessage("blah", thrift.TMessageType.CALL, 0));
        t_foo_file.blah_args args = new t_foo_file.blah_args();
        args.num = num;
        args.str = str;
        args.event = event;
        args.write(oprot);
        oprot.writeMessageEnd();
        await oprot.transport.flush();
      } finally {
        writeLock.unlock();
      }

      return await controller.stream.first.timeout(ctx.timeout);
    } finally {
      closeSubscription.cancel();
      _transport.unregister(ctx);
    }
  }

  _recvBlahHandler(frugal.FContext ctx, StreamController controller) {
    blahCallback(thrift.TTransport transport) {
      try {
        var iprot = _protocolFactory.getProtocol(transport);
        iprot.readResponseHeader(ctx);
        thrift.TMessage msg = iprot.readMessageBegin();
        if (msg.type == thrift.TMessageType.EXCEPTION) {
          thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
          iprot.readMessageEnd();
          if (error.type == frugal.FTransport.RESPONSE_TOO_LARGE) {
            controller.addError(new frugal.FMessageSizeError.response());
            return;
          }
          if (error.type == frugal.FRateLimitError.RATE_LIMIT_EXCEEDED) {
            controller.addError(new frugal.FRateLimitError());
            return;
          }
          throw error;
        }

        t_foo_file.blah_result result = new t_foo_file.blah_result();
        result.read(iprot);
        iprot.readMessageEnd();
        if (result.isSetSuccess()) {
          controller.add(result.success);
          return;
        }

        if (result.awe != null) {
          controller.addError(result.awe);
          return;
        }
        if (result.api != null) {
          controller.addError(result.api);
          return;
        }
        throw new thrift.TApplicationError(
          thrift.TApplicationErrorType.MISSING_RESULT, "blah failed: unknown result"
        );
      } catch(e) {
        controller.addError(e);
        rethrow;
      }
    }
    return blahCallback;
  }

  /// oneway methods don't receive a response from the server.
  Future oneWay(frugal.FContext ctx, int id, Map<int, String> req) {
    return this._methods['oneWay']([ctx, id, req]);
  }

  Future _oneWay(frugal.FContext ctx, int id, Map<int, String> req) async {
    await writeLock.lock();
    try {
      oprot.writeRequestHeader(ctx);
      oprot.writeMessageBegin(new thrift.TMessage("oneWay", thrift.TMessageType.ONEWAY, 0));
      t_foo_file.oneWay_args args = new t_foo_file.oneWay_args();
      args.id = id;
      args.req = req;
      args.write(oprot);
      oprot.writeMessageEnd();
      await oprot.transport.flush();
    } finally {
      writeLock.unlock();
    }
  }

  Future<Uint8List> bin_method(frugal.FContext ctx, Uint8List bin, String str) {
    return this._methods['bin_method']([ctx, bin, str]);
  }

  Future<Uint8List> _bin_method(frugal.FContext ctx, Uint8List bin, String str) async {
    var controller = new StreamController();
    var closeSubscription = _transport.onClose.listen((_) {
      controller.addError(new thrift.TTransportError(
        thrift.TTransportErrorType.NOT_OPEN,
        "Transport closed before request completed."));
      });
    _transport.register(ctx, _recvBin_methodHandler(ctx, controller));
    await writeLock.lock();
    try {
      try {
        oprot.writeRequestHeader(ctx);
        oprot.writeMessageBegin(new thrift.TMessage("bin_method", thrift.TMessageType.CALL, 0));
        t_foo_file.bin_method_args args = new t_foo_file.bin_method_args();
        args.bin = bin;
        args.str = str;
        args.write(oprot);
        oprot.writeMessageEnd();
        await oprot.transport.flush();
      } finally {
        writeLock.unlock();
      }

      return await controller.stream.first.timeout(ctx.timeout);
    } finally {
      closeSubscription.cancel();
      _transport.unregister(ctx);
    }
  }

  _recvBin_methodHandler(frugal.FContext ctx, StreamController controller) {
    bin_methodCallback(thrift.TTransport transport) {
      try {
        var iprot = _protocolFactory.getProtocol(transport);
        iprot.readResponseHeader(ctx);
        thrift.TMessage msg = iprot.readMessageBegin();
        if (msg.type == thrift.TMessageType.EXCEPTION) {
          thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
          iprot.readMessageEnd();
          if (error.type == frugal.FTransport.RESPONSE_TOO_LARGE) {
            controller.addError(new frugal.FMessageSizeError.response());
            return;
          }
          if (error.type == frugal.FRateLimitError.RATE_LIMIT_EXCEEDED) {
            controller.addError(new frugal.FRateLimitError());
            return;
          }
          throw error;
        }

        t_foo_file.bin_method_result result = new t_foo_file.bin_method_result();
        result.read(iprot);
        iprot.readMessageEnd();
        if (result.isSetSuccess()) {
          controller.add(result.success);
          return;
        }

        if (result.api != null) {
          controller.addError(result.api);
          return;
        }
        throw new thrift.TApplicationError(
          thrift.TApplicationErrorType.MISSING_RESULT, "bin_method failed: unknown result"
        );
      } catch(e) {
        controller.addError(e);
        rethrow;
      }
    }
    return bin_methodCallback;
  }

  Future<int> param_modifiers(frugal.FContext ctx, int opt_num, int default_num, int req_num) {
    return this._methods['param_modifiers']([ctx, opt_num, default_num, req_num]);
  }

  Future<int> _param_modifiers(frugal.FContext ctx, int opt_num, int default_num, int req_num) async {
    var controller = new StreamController();
    var closeSubscription = _transport.onClose.listen((_) {
      controller.addError(new thrift.TTransportError(
        thrift.TTransportErrorType.NOT_OPEN,
        "Transport closed before request completed."));
      });
    _transport.register(ctx, _recvParam_modifiersHandler(ctx, controller));
    await writeLock.lock();
    try {
      try {
        oprot.writeRequestHeader(ctx);
        oprot.writeMessageBegin(new thrift.TMessage("param_modifiers", thrift.TMessageType.CALL, 0));
        t_foo_file.param_modifiers_args args = new t_foo_file.param_modifiers_args();
        args.opt_num = opt_num;
        args.default_num = default_num;
        args.req_num = req_num;
        args.write(oprot);
        oprot.writeMessageEnd();
        await oprot.transport.flush();
      } finally {
        writeLock.unlock();
      }

      return await controller.stream.first.timeout(ctx.timeout);
    } finally {
      closeSubscription.cancel();
      _transport.unregister(ctx);
    }
  }

  _recvParam_modifiersHandler(frugal.FContext ctx, StreamController controller) {
    param_modifiersCallback(thrift.TTransport transport) {
      try {
        var iprot = _protocolFactory.getProtocol(transport);
        iprot.readResponseHeader(ctx);
        thrift.TMessage msg = iprot.readMessageBegin();
        if (msg.type == thrift.TMessageType.EXCEPTION) {
          thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
          iprot.readMessageEnd();
          if (error.type == frugal.FTransport.RESPONSE_TOO_LARGE) {
            controller.addError(new frugal.FMessageSizeError.response());
            return;
          }
          if (error.type == frugal.FRateLimitError.RATE_LIMIT_EXCEEDED) {
            controller.addError(new frugal.FRateLimitError());
            return;
          }
          throw error;
        }

        t_foo_file.param_modifiers_result result = new t_foo_file.param_modifiers_result();
        result.read(iprot);
        iprot.readMessageEnd();
        if (result.isSetSuccess()) {
          controller.add(result.success);
          return;
        }

        throw new thrift.TApplicationError(
          thrift.TApplicationErrorType.MISSING_RESULT, "param_modifiers failed: unknown result"
        );
      } catch(e) {
        controller.addError(e);
        rethrow;
      }
    }
    return param_modifiersCallback;
  }

  Future<List<int>> underlying_types_test(frugal.FContext ctx, List<int> list_type, Set<int> set_type) {
    return this._methods['underlying_types_test']([ctx, list_type, set_type]);
  }

  Future<List<int>> _underlying_types_test(frugal.FContext ctx, List<int> list_type, Set<int> set_type) async {
    var controller = new StreamController();
    var closeSubscription = _transport.onClose.listen((_) {
      controller.addError(new thrift.TTransportError(
        thrift.TTransportErrorType.NOT_OPEN,
        "Transport closed before request completed."));
      });
    _transport.register(ctx, _recvUnderlying_types_testHandler(ctx, controller));
    await writeLock.lock();
    try {
      try {
        oprot.writeRequestHeader(ctx);
        oprot.writeMessageBegin(new thrift.TMessage("underlying_types_test", thrift.TMessageType.CALL, 0));
        t_foo_file.underlying_types_test_args args = new t_foo_file.underlying_types_test_args();
        args.list_type = list_type;
        args.set_type = set_type;
        args.write(oprot);
        oprot.writeMessageEnd();
        await oprot.transport.flush();
      } finally {
        writeLock.unlock();
      }

      return await controller.stream.first.timeout(ctx.timeout);
    } finally {
      closeSubscription.cancel();
      _transport.unregister(ctx);
    }
  }

  _recvUnderlying_types_testHandler(frugal.FContext ctx, StreamController controller) {
    underlying_types_testCallback(thrift.TTransport transport) {
      try {
        var iprot = _protocolFactory.getProtocol(transport);
        iprot.readResponseHeader(ctx);
        thrift.TMessage msg = iprot.readMessageBegin();
        if (msg.type == thrift.TMessageType.EXCEPTION) {
          thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
          iprot.readMessageEnd();
          if (error.type == frugal.FTransport.RESPONSE_TOO_LARGE) {
            controller.addError(new frugal.FMessageSizeError.response());
            return;
          }
          if (error.type == frugal.FRateLimitError.RATE_LIMIT_EXCEEDED) {
            controller.addError(new frugal.FRateLimitError());
            return;
          }
          throw error;
        }

        t_foo_file.underlying_types_test_result result = new t_foo_file.underlying_types_test_result();
        result.read(iprot);
        iprot.readMessageEnd();
        if (result.isSetSuccess()) {
          controller.add(result.success);
          return;
        }

        throw new thrift.TApplicationError(
          thrift.TApplicationErrorType.MISSING_RESULT, "underlying_types_test failed: unknown result"
        );
      } catch(e) {
        controller.addError(e);
        rethrow;
      }
    }
    return underlying_types_testCallback;
  }

}
