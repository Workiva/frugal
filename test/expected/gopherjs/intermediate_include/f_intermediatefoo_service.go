// Autogenerated by Frugal Compiler (2.23.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package intermediate_include

import (
	"errors"

	"github.com/Workiva/frugal/lib/gopherjs/frugal"
)

// IntermediateFoo is a service or a client.
type IntermediateFoo interface {
	IntermeidateFoo(ctx frugal.Context) (err error)
}

// IntermediateFooClient is the client.
type IntermediateFooClient struct {
	call frugal.CallFunc
}

// NewIntermediateFooClient constructs a IntermediateFooClient.
func NewIntermediateFooClient(cf frugal.CallFunc) *IntermediateFooClient {
	return &IntermediateFooClient{
		call: cf,
	}
}

// IntermeidateFoo calls a server.
func (c *IntermediateFooClient) IntermeidateFoo(ctx frugal.Context) (err error) {
	args := &IntermediateFooIntermeidateFooArgs{}
	res := &IntermediateFooIntermeidateFooResult{}
	err = c.call(ctx, "intermediateFoo", "intermeidateFoo", args, res)
	if err != nil {
		return
	}
	return nil
}

// IntermediateFooProcessor is the client.
type IntermediateFooProcessor struct {
	handler IntermediateFoo
}

// NewIntermediateFooProcessor constructs a IntermediateFooProcessor.
func NewIntermediateFooProcessor(handler IntermediateFoo) *IntermediateFooProcessor {
	return &IntermediateFooProcessor{
		handler: handler,
	}
}

// Invoke handles internal processing of IntermediateFoo invocations.
func (p *IntermediateFooProcessor) Invoke(ctx frugal.Context, method string, in frugal.Protocol) (frugal.Packer, error) {
	switch method {
	case "intermeidateFoo":
		args := &IntermediateFooIntermeidateFooArgs{}
		args.Unpack(in)
		err := in.Err()
		if err != nil {
			return nil, err
		}
		res := &IntermediateFooIntermeidateFooResult{}
		err = p.handler.IntermeidateFoo(ctx)
		return res, err
	default:
		return nil, errors.New("IntermediateFoo: unsupported method " + method)
	}
}

// IntermediateFooIntermeidateFooArgs is a frual serializable object.
type IntermediateFooIntermeidateFooArgs struct {
}

// NewIntermediateFooIntermeidateFooArgs constructs a IntermediateFooIntermeidateFooArgs.
func NewIntermediateFooIntermeidateFooArgs() *IntermediateFooIntermeidateFooArgs {
	return &IntermediateFooIntermeidateFooArgs{
		// TODO: default values

	}
}

// Unpack deserializes IntermediateFooIntermeidateFooArgs objects.
func (p *IntermediateFooIntermeidateFooArgs) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("IntermediateFooIntermeidateFooArgs")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes IntermediateFooIntermeidateFooArgs objects.
func (p *IntermediateFooIntermeidateFooArgs) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("IntermediateFooIntermeidateFooArgs")
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// IntermediateFooIntermeidateFooResult is a frual serializable object.
type IntermediateFooIntermeidateFooResult struct {
}

// NewIntermediateFooIntermeidateFooResult constructs a IntermediateFooIntermeidateFooResult.
func NewIntermediateFooIntermeidateFooResult() *IntermediateFooIntermeidateFooResult {
	return &IntermediateFooIntermeidateFooResult{
		// TODO: default values

	}
}

// Unpack deserializes IntermediateFooIntermeidateFooResult objects.
func (p *IntermediateFooIntermeidateFooResult) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("IntermediateFooIntermeidateFooResult")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes IntermediateFooIntermeidateFooResult objects.
func (p *IntermediateFooIntermeidateFooResult) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("IntermediateFooIntermeidateFooResult")
	prot.PackFieldStop()
	prot.PackStructEnd()
}
