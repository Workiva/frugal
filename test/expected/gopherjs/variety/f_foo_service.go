// Autogenerated by Frugal Compiler (2.23.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package variety

import (
	"errors"

	"github.com/Workiva/frugal/lib/gopherjs/frugal"
	"github.com/Workiva/frugal/test/expected/gopherjs/ValidTypes"
	"github.com/Workiva/frugal/test/expected/gopherjs/base"
	"github.com/Workiva/frugal/test/expected/gopherjs/subdir_include"
	"github.com/Workiva/frugal/test/expected/gopherjs/validStructs"
)

// Foo is a service or a client.
type Foo interface {
	Ping(ctx frugal.Context) (err error)
	Blah(ctx frugal.Context, num int32, Str string, event *Event) (r int64, err error)
	OneWay(ctx frugal.Context, id ID, req Request) (err error)
	BinMethod(ctx frugal.Context, bin []byte, Str string) (r []byte, err error)
	ParamModifiers(ctx frugal.Context, opt_num int32, default_num int32, req_num int32) (r int64, err error)
	UnderlyingTypesTest(ctx frugal.Context, list_type []ID, set_type map[ID]bool) (r []ID, err error)
	GetThing(ctx frugal.Context) (r *validStructs.Thing, err error)
	GetMyInt(ctx frugal.Context) (r ValidTypes.MyInt, err error)
	UseSubdirStruct(ctx frugal.Context, a *subdir_include.A) (r *subdir_include.A, err error)
	SayHelloWith(ctx frugal.Context, newMessage string) (r string, err error)
	WhatDoYouSay(ctx frugal.Context, messageArgs string) (r string, err error)
	SayAgain(ctx frugal.Context, messageResult string) (r string, err error)
}

// FooClient is the client.
type FooClient struct {
	call frugal.CallFunc
}

// NewFooClient constructs a FooClient.
func NewFooClient(cf frugal.CallFunc) *FooClient {
	return &FooClient{
		call: cf,
	}
}

// Ping calls a server.
func (c *FooClient) Ping(ctx frugal.Context) (err error) {
	args := &FooPingArgs{}
	res := &FooPingResult{}
	err = c.call(ctx, "foo", "ping", args, res)
	if err != nil {
		return
	}
	return nil
}

// Blah calls a server.
func (c *FooClient) Blah(ctx frugal.Context, num int32, Str string, event *Event) (r int64, err error) {
	args := &FooBlahArgs{
		Num:   num,
		Str:   Str,
		Event: event,
	}
	res := &FooBlahResult{}
	err = c.call(ctx, "foo", "blah", args, res)
	if err != nil {
		return
	}
	if err = res.Awe; err != nil {
		return
	}
	if err = res.API; err != nil {
		return
	}
	return res.Success, nil
}

// OneWay calls a server.
func (c *FooClient) OneWay(ctx frugal.Context, id ID, req Request) (err error) {
	args := &FooOneWayArgs{
		ID:  id,
		Req: req,
	}
	return c.call(ctx, "foo", "oneWay", args, nil)
}

// BinMethod calls a server.
func (c *FooClient) BinMethod(ctx frugal.Context, bin []byte, Str string) (r []byte, err error) {
	args := &FooBinMethodArgs{
		Bin: bin,
		Str: Str,
	}
	res := &FooBinMethodResult{}
	err = c.call(ctx, "foo", "bin_method", args, res)
	if err != nil {
		return
	}
	if err = res.API; err != nil {
		return
	}
	return res.Success, nil
}

// ParamModifiers calls a server.
func (c *FooClient) ParamModifiers(ctx frugal.Context, opt_num int32, default_num int32, req_num int32) (r int64, err error) {
	args := &FooParamModifiersArgs{
		OptNum:     opt_num,
		DefaultNum: default_num,
		ReqNum:     req_num,
	}
	res := &FooParamModifiersResult{}
	err = c.call(ctx, "foo", "param_modifiers", args, res)
	if err != nil {
		return
	}
	return res.Success, nil
}

// UnderlyingTypesTest calls a server.
func (c *FooClient) UnderlyingTypesTest(ctx frugal.Context, list_type []ID, set_type map[ID]bool) (r []ID, err error) {
	args := &FooUnderlyingTypesTestArgs{
		ListType: list_type,
		SetType:  set_type,
	}
	res := &FooUnderlyingTypesTestResult{}
	err = c.call(ctx, "foo", "underlying_types_test", args, res)
	if err != nil {
		return
	}
	return res.Success, nil
}

// GetThing calls a server.
func (c *FooClient) GetThing(ctx frugal.Context) (r *validStructs.Thing, err error) {
	args := &FooGetThingArgs{}
	res := &FooGetThingResult{}
	err = c.call(ctx, "foo", "getThing", args, res)
	if err != nil {
		return
	}
	return res.Success, nil
}

// GetMyInt calls a server.
func (c *FooClient) GetMyInt(ctx frugal.Context) (r ValidTypes.MyInt, err error) {
	args := &FooGetMyIntArgs{}
	res := &FooGetMyIntResult{}
	err = c.call(ctx, "foo", "getMyInt", args, res)
	if err != nil {
		return
	}
	return res.Success, nil
}

// UseSubdirStruct calls a server.
func (c *FooClient) UseSubdirStruct(ctx frugal.Context, a *subdir_include.A) (r *subdir_include.A, err error) {
	args := &FooUseSubdirStructArgs{
		A: a,
	}
	res := &FooUseSubdirStructResult{}
	err = c.call(ctx, "foo", "use_subdir_struct", args, res)
	if err != nil {
		return
	}
	return res.Success, nil
}

// SayHelloWith calls a server.
func (c *FooClient) SayHelloWith(ctx frugal.Context, newMessage string) (r string, err error) {
	args := &FooSayHelloWithArgs{
		NewMessage: newMessage,
	}
	res := &FooSayHelloWithResult{}
	err = c.call(ctx, "foo", "sayHelloWith", args, res)
	if err != nil {
		return
	}
	return res.Success, nil
}

// WhatDoYouSay calls a server.
func (c *FooClient) WhatDoYouSay(ctx frugal.Context, messageArgs string) (r string, err error) {
	args := &FooWhatDoYouSayArgs{
		MessageArgs: messageArgs,
	}
	res := &FooWhatDoYouSayResult{}
	err = c.call(ctx, "foo", "whatDoYouSay", args, res)
	if err != nil {
		return
	}
	return res.Success, nil
}

// SayAgain calls a server.
func (c *FooClient) SayAgain(ctx frugal.Context, messageResult string) (r string, err error) {
	args := &FooSayAgainArgs{
		MessageResult: messageResult,
	}
	res := &FooSayAgainResult{}
	err = c.call(ctx, "foo", "sayAgain", args, res)
	if err != nil {
		return
	}
	return res.Success, nil
}

// FooProcessor is the client.
type FooProcessor struct {
	handler Foo
}

// NewFooProcessor constructs a FooProcessor.
func NewFooProcessor(handler Foo) *FooProcessor {
	return &FooProcessor{
		handler: handler,
	}
}

// Invoke handles internal processing of Foo invocations.
func (p *FooProcessor) Invoke(ctx frugal.Context, method string, in frugal.Protocol) (frugal.Packer, error) {
	switch method {
	case "ping":
		args := &FooPingArgs{}
		args.Unpack(in)
		err := in.Err()
		if err != nil {
			return nil, err
		}
		res := &FooPingResult{}
		err = p.handler.Ping(ctx)
		return res, err
	case "blah":
		args := &FooBlahArgs{}
		args.Unpack(in)
		err := in.Err()
		if err != nil {
			return nil, err
		}
		res := &FooBlahResult{}
		res.Success, err = p.handler.Blah(ctx, args.Num, args.Str, args.Event)
		switch terr := err.(type) {
		case *AwesomeException:
			res.Awe = terr
			err = nil
		case *base.APIException:
			res.API = terr
			err = nil
		}
		return res, err
	case "oneWay":
		args := &FooOneWayArgs{}
		args.Unpack(in)
		err := in.Err()
		if err != nil {
			return nil, err
		}
		res := &FooOneWayResult{}
		err = p.handler.OneWay(ctx, args.ID, args.Req)
		return res, err
	case "bin_method":
		args := &FooBinMethodArgs{}
		args.Unpack(in)
		err := in.Err()
		if err != nil {
			return nil, err
		}
		res := &FooBinMethodResult{}
		res.Success, err = p.handler.BinMethod(ctx, args.Bin, args.Str)
		switch terr := err.(type) {
		case *base.APIException:
			res.API = terr
			err = nil
		}
		return res, err
	case "param_modifiers":
		args := &FooParamModifiersArgs{}
		args.Unpack(in)
		err := in.Err()
		if err != nil {
			return nil, err
		}
		res := &FooParamModifiersResult{}
		res.Success, err = p.handler.ParamModifiers(ctx, args.OptNum, args.DefaultNum, args.ReqNum)
		return res, err
	case "underlying_types_test":
		args := &FooUnderlyingTypesTestArgs{}
		args.Unpack(in)
		err := in.Err()
		if err != nil {
			return nil, err
		}
		res := &FooUnderlyingTypesTestResult{}
		res.Success, err = p.handler.UnderlyingTypesTest(ctx, args.ListType, args.SetType)
		return res, err
	case "getThing":
		args := &FooGetThingArgs{}
		args.Unpack(in)
		err := in.Err()
		if err != nil {
			return nil, err
		}
		res := &FooGetThingResult{}
		res.Success, err = p.handler.GetThing(ctx)
		return res, err
	case "getMyInt":
		args := &FooGetMyIntArgs{}
		args.Unpack(in)
		err := in.Err()
		if err != nil {
			return nil, err
		}
		res := &FooGetMyIntResult{}
		res.Success, err = p.handler.GetMyInt(ctx)
		return res, err
	case "use_subdir_struct":
		args := &FooUseSubdirStructArgs{}
		args.Unpack(in)
		err := in.Err()
		if err != nil {
			return nil, err
		}
		res := &FooUseSubdirStructResult{}
		res.Success, err = p.handler.UseSubdirStruct(ctx, args.A)
		return res, err
	case "sayHelloWith":
		args := &FooSayHelloWithArgs{}
		args.Unpack(in)
		err := in.Err()
		if err != nil {
			return nil, err
		}
		res := &FooSayHelloWithResult{}
		res.Success, err = p.handler.SayHelloWith(ctx, args.NewMessage)
		return res, err
	case "whatDoYouSay":
		args := &FooWhatDoYouSayArgs{}
		args.Unpack(in)
		err := in.Err()
		if err != nil {
			return nil, err
		}
		res := &FooWhatDoYouSayResult{}
		res.Success, err = p.handler.WhatDoYouSay(ctx, args.MessageArgs)
		return res, err
	case "sayAgain":
		args := &FooSayAgainArgs{}
		args.Unpack(in)
		err := in.Err()
		if err != nil {
			return nil, err
		}
		res := &FooSayAgainResult{}
		res.Success, err = p.handler.SayAgain(ctx, args.MessageResult)
		return res, err
	default:
		return nil, errors.New("Foo: unsupported method " + method)
	}
}

// FooPingArgs is a frual serializable object.
type FooPingArgs struct {
}

// NewFooPingArgs constructs a FooPingArgs.
func NewFooPingArgs() *FooPingArgs {
	return &FooPingArgs{
		// TODO: default values

	}
}

// Unpack deserializes FooPingArgs objects.
func (p *FooPingArgs) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("FooPingArgs")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes FooPingArgs objects.
func (p *FooPingArgs) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("FooPingArgs")
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// FooPingResult is a frual serializable object.
type FooPingResult struct {
}

// NewFooPingResult constructs a FooPingResult.
func NewFooPingResult() *FooPingResult {
	return &FooPingResult{
		// TODO: default values

	}
}

// Unpack deserializes FooPingResult objects.
func (p *FooPingResult) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("FooPingResult")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes FooPingResult objects.
func (p *FooPingResult) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("FooPingResult")
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// FooBlahArgs is a frual serializable object.
type FooBlahArgs struct {
	Num   int32
	Str   string
	Event *Event
}

// NewFooBlahArgs constructs a FooBlahArgs.
func NewFooBlahArgs() *FooBlahArgs {
	return &FooBlahArgs{
		// TODO: default values

	}
}

// Unpack deserializes FooBlahArgs objects.
func (p *FooBlahArgs) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("FooBlahArgs")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		case 1:
			p.Num = prot.UnpackI32()
		case 2:
			p.Str = prot.UnpackString()
		case 3:
			p.Event = NewEvent()
			p.Event.Unpack(prot)
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes FooBlahArgs objects.
func (p *FooBlahArgs) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("FooBlahArgs")
	prot.PackI32("num", 1, int32(p.Num))
	prot.PackString("Str", 2, string(p.Str))
	prot.PackFieldBegin("event", frugal.STRUCT, 3)
	p.Event.Pack(prot)
	prot.PackFieldEnd(3)
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// FooBlahResult is a frual serializable object.
type FooBlahResult struct {
	Success *int64
	Awe     *AwesomeException
	API     *base.APIException
}

// NewFooBlahResult constructs a FooBlahResult.
func NewFooBlahResult() *FooBlahResult {
	return &FooBlahResult{
		// TODO: default values

	}
}

// Unpack deserializes FooBlahResult objects.
func (p *FooBlahResult) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("FooBlahResult")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		case 0:
			v := prot.UnpackI64()
			p.Success = &v
		case 1:
			p.Awe = NewAwesomeException()
			p.Awe.Unpack(prot)
		case 2:
			p.API = base.NewAPIException()
			p.API.Unpack(prot)
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes FooBlahResult objects.
func (p *FooBlahResult) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("FooBlahResult")
	if p.Success != nil {
		prot.PackI64("success", 0, int64(*p.Success))
	}
	if p.Awe != nil {
		prot.PackFieldBegin("awe", frugal.STRUCT, 1)
		p.Awe.Pack(prot)
		prot.PackFieldEnd(1)
	}
	if p.API != nil {
		prot.PackFieldBegin("api", frugal.STRUCT, 2)
		p.API.Pack(prot)
		prot.PackFieldEnd(2)
	}
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// FooOneWayArgs is a frual serializable object.
type FooOneWayArgs struct {
	ID  ID
	Req Request
}

// NewFooOneWayArgs constructs a FooOneWayArgs.
func NewFooOneWayArgs() *FooOneWayArgs {
	return &FooOneWayArgs{
		// TODO: default values

	}
}

// Unpack deserializes FooOneWayArgs objects.
func (p *FooOneWayArgs) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("FooOneWayArgs")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		case 1:
			p.ID = ID(prot.UnpackI64())
		case 2:
			size := prot.UnpackMapBegin()
			p.Req = make(Request, size)
			for i := 0; i < size; i++ {
				elem15 := Int(prot.UnpackI32())
				elem16 := prot.UnpackString()
				(p.Req)[elem15] = elem16
			}
			prot.UnpackMapEnd()
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes FooOneWayArgs objects.
func (p *FooOneWayArgs) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("FooOneWayArgs")
	prot.PackI64("id", 1, int64(p.ID))
	prot.PackMapBegin("req", 2, frugal.I32, frugal.STRING, len(p.Req))
	for k, v := range p.Req {
		prot.PackI32("", -1, int32(k))
		prot.PackString("", -1, string(v))
	}
	prot.PackMapEnd(2)
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// FooBinMethodArgs is a frual serializable object.
type FooBinMethodArgs struct {
	Bin []byte
	Str string
}

// NewFooBinMethodArgs constructs a FooBinMethodArgs.
func NewFooBinMethodArgs() *FooBinMethodArgs {
	return &FooBinMethodArgs{
		// TODO: default values

	}
}

// Unpack deserializes FooBinMethodArgs objects.
func (p *FooBinMethodArgs) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("FooBinMethodArgs")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		case 1:
			p.Bin = prot.UnpackBinary()
		case 2:
			p.Str = prot.UnpackString()
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes FooBinMethodArgs objects.
func (p *FooBinMethodArgs) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("FooBinMethodArgs")
	prot.PackBinary("bin", 1, []byte(p.Bin))
	prot.PackString("Str", 2, string(p.Str))
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// FooBinMethodResult is a frual serializable object.
type FooBinMethodResult struct {
	Success []byte
	API     *base.APIException
}

// NewFooBinMethodResult constructs a FooBinMethodResult.
func NewFooBinMethodResult() *FooBinMethodResult {
	return &FooBinMethodResult{
		// TODO: default values

	}
}

// Unpack deserializes FooBinMethodResult objects.
func (p *FooBinMethodResult) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("FooBinMethodResult")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		case 0:
			p.Success = prot.UnpackBinary()
		case 1:
			p.API = base.NewAPIException()
			p.API.Unpack(prot)
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes FooBinMethodResult objects.
func (p *FooBinMethodResult) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("FooBinMethodResult")
	if p.Success != nil {
		prot.PackBinary("success", 0, []byte(p.Success))
	}
	if p.API != nil {
		prot.PackFieldBegin("api", frugal.STRUCT, 1)
		p.API.Pack(prot)
		prot.PackFieldEnd(1)
	}
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// FooParamModifiersArgs is a frual serializable object.
type FooParamModifiersArgs struct {
	OptNum     int32
	DefaultNum int32
	ReqNum     int32
}

// NewFooParamModifiersArgs constructs a FooParamModifiersArgs.
func NewFooParamModifiersArgs() *FooParamModifiersArgs {
	return &FooParamModifiersArgs{
		// TODO: default values

	}
}

// Unpack deserializes FooParamModifiersArgs objects.
func (p *FooParamModifiersArgs) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("FooParamModifiersArgs")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		case 1:
			p.OptNum = prot.UnpackI32()
		case 2:
			p.DefaultNum = prot.UnpackI32()
		case 3:
			p.ReqNum = prot.UnpackI32()
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes FooParamModifiersArgs objects.
func (p *FooParamModifiersArgs) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("FooParamModifiersArgs")
	prot.PackI32("opt_num", 1, int32(p.OptNum))
	prot.PackI32("default_num", 2, int32(p.DefaultNum))
	prot.PackI32("req_num", 3, int32(p.ReqNum))
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// FooParamModifiersResult is a frual serializable object.
type FooParamModifiersResult struct {
	Success *int64
}

// NewFooParamModifiersResult constructs a FooParamModifiersResult.
func NewFooParamModifiersResult() *FooParamModifiersResult {
	return &FooParamModifiersResult{
		// TODO: default values

	}
}

// Unpack deserializes FooParamModifiersResult objects.
func (p *FooParamModifiersResult) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("FooParamModifiersResult")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		case 0:
			v := prot.UnpackI64()
			p.Success = &v
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes FooParamModifiersResult objects.
func (p *FooParamModifiersResult) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("FooParamModifiersResult")
	if p.Success != nil {
		prot.PackI64("success", 0, int64(*p.Success))
	}
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// FooUnderlyingTypesTestArgs is a frual serializable object.
type FooUnderlyingTypesTestArgs struct {
	ListType []ID
	SetType  map[ID]bool
}

// NewFooUnderlyingTypesTestArgs constructs a FooUnderlyingTypesTestArgs.
func NewFooUnderlyingTypesTestArgs() *FooUnderlyingTypesTestArgs {
	return &FooUnderlyingTypesTestArgs{
		// TODO: default values

	}
}

// Unpack deserializes FooUnderlyingTypesTestArgs objects.
func (p *FooUnderlyingTypesTestArgs) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("FooUnderlyingTypesTestArgs")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		case 1:
			size := prot.UnpackListBegin()
			if size > 0 {
				p.ListType = make([]ID, size)
				for i := 0; i < size; i++ {
					(p.ListType)[i] = ID(prot.UnpackI64())
				}
			}
			prot.UnpackListEnd()
		case 2:
			// TODO: sets! SetType
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes FooUnderlyingTypesTestArgs objects.
func (p *FooUnderlyingTypesTestArgs) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("FooUnderlyingTypesTestArgs")
	prot.PackListBegin("list_type", 1, frugal.I64, len(p.ListType))
	for _, v := range p.ListType {
		prot.PackI64("", -1, int64(v))
	}
	prot.PackListEnd(1)
	// TODO: sets p.SetType
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// FooUnderlyingTypesTestResult is a frual serializable object.
type FooUnderlyingTypesTestResult struct {
	Success []ID
}

// NewFooUnderlyingTypesTestResult constructs a FooUnderlyingTypesTestResult.
func NewFooUnderlyingTypesTestResult() *FooUnderlyingTypesTestResult {
	return &FooUnderlyingTypesTestResult{
		// TODO: default values

	}
}

// Unpack deserializes FooUnderlyingTypesTestResult objects.
func (p *FooUnderlyingTypesTestResult) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("FooUnderlyingTypesTestResult")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		case 0:
			size := prot.UnpackListBegin()
			if size > 0 {
				p.Success = make([]ID, size)
				for i := 0; i < size; i++ {
					(p.Success)[i] = ID(prot.UnpackI64())
				}
			}
			prot.UnpackListEnd()
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes FooUnderlyingTypesTestResult objects.
func (p *FooUnderlyingTypesTestResult) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("FooUnderlyingTypesTestResult")
	if p.Success != nil {
		prot.PackListBegin("success", 0, frugal.I64, len(p.Success))
		for _, v := range p.Success {
			prot.PackI64("", -1, int64(v))
		}
		prot.PackListEnd(0)
	}
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// FooGetThingArgs is a frual serializable object.
type FooGetThingArgs struct {
}

// NewFooGetThingArgs constructs a FooGetThingArgs.
func NewFooGetThingArgs() *FooGetThingArgs {
	return &FooGetThingArgs{
		// TODO: default values

	}
}

// Unpack deserializes FooGetThingArgs objects.
func (p *FooGetThingArgs) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("FooGetThingArgs")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes FooGetThingArgs objects.
func (p *FooGetThingArgs) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("FooGetThingArgs")
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// FooGetThingResult is a frual serializable object.
type FooGetThingResult struct {
	Success *validStructs.Thing
}

// NewFooGetThingResult constructs a FooGetThingResult.
func NewFooGetThingResult() *FooGetThingResult {
	return &FooGetThingResult{
		// TODO: default values

	}
}

// Unpack deserializes FooGetThingResult objects.
func (p *FooGetThingResult) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("FooGetThingResult")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		case 0:
			p.Success = validStructs.NewThing()
			p.Success.Unpack(prot)
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes FooGetThingResult objects.
func (p *FooGetThingResult) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("FooGetThingResult")
	if p.Success != nil {
		prot.PackFieldBegin("success", frugal.STRUCT, 0)
		p.Success.Pack(prot)
		prot.PackFieldEnd(0)
	}
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// FooGetMyIntArgs is a frual serializable object.
type FooGetMyIntArgs struct {
}

// NewFooGetMyIntArgs constructs a FooGetMyIntArgs.
func NewFooGetMyIntArgs() *FooGetMyIntArgs {
	return &FooGetMyIntArgs{
		// TODO: default values

	}
}

// Unpack deserializes FooGetMyIntArgs objects.
func (p *FooGetMyIntArgs) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("FooGetMyIntArgs")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes FooGetMyIntArgs objects.
func (p *FooGetMyIntArgs) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("FooGetMyIntArgs")
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// FooGetMyIntResult is a frual serializable object.
type FooGetMyIntResult struct {
	Success *ValidTypes.MyInt
}

// NewFooGetMyIntResult constructs a FooGetMyIntResult.
func NewFooGetMyIntResult() *FooGetMyIntResult {
	return &FooGetMyIntResult{
		// TODO: default values

	}
}

// Unpack deserializes FooGetMyIntResult objects.
func (p *FooGetMyIntResult) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("FooGetMyIntResult")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		case 0:
			temp := ValidTypes.MyInt(prot.UnpackI32())
			p.Success = &temp
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes FooGetMyIntResult objects.
func (p *FooGetMyIntResult) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("FooGetMyIntResult")
	if p.Success != nil {
		prot.PackI32("success", 0, int32(*p.Success))
	}
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// FooUseSubdirStructArgs is a frual serializable object.
type FooUseSubdirStructArgs struct {
	A *subdir_include.A
}

// NewFooUseSubdirStructArgs constructs a FooUseSubdirStructArgs.
func NewFooUseSubdirStructArgs() *FooUseSubdirStructArgs {
	return &FooUseSubdirStructArgs{
		// TODO: default values

	}
}

// Unpack deserializes FooUseSubdirStructArgs objects.
func (p *FooUseSubdirStructArgs) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("FooUseSubdirStructArgs")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		case 1:
			p.A = subdir_include.NewA()
			p.A.Unpack(prot)
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes FooUseSubdirStructArgs objects.
func (p *FooUseSubdirStructArgs) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("FooUseSubdirStructArgs")
	prot.PackFieldBegin("a", frugal.STRUCT, 1)
	p.A.Pack(prot)
	prot.PackFieldEnd(1)
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// FooUseSubdirStructResult is a frual serializable object.
type FooUseSubdirStructResult struct {
	Success *subdir_include.A
}

// NewFooUseSubdirStructResult constructs a FooUseSubdirStructResult.
func NewFooUseSubdirStructResult() *FooUseSubdirStructResult {
	return &FooUseSubdirStructResult{
		// TODO: default values

	}
}

// Unpack deserializes FooUseSubdirStructResult objects.
func (p *FooUseSubdirStructResult) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("FooUseSubdirStructResult")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		case 0:
			p.Success = subdir_include.NewA()
			p.Success.Unpack(prot)
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes FooUseSubdirStructResult objects.
func (p *FooUseSubdirStructResult) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("FooUseSubdirStructResult")
	if p.Success != nil {
		prot.PackFieldBegin("success", frugal.STRUCT, 0)
		p.Success.Pack(prot)
		prot.PackFieldEnd(0)
	}
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// FooSayHelloWithArgs is a frual serializable object.
type FooSayHelloWithArgs struct {
	NewMessage string
}

// NewFooSayHelloWithArgs constructs a FooSayHelloWithArgs.
func NewFooSayHelloWithArgs() *FooSayHelloWithArgs {
	return &FooSayHelloWithArgs{
		// TODO: default values

	}
}

// Unpack deserializes FooSayHelloWithArgs objects.
func (p *FooSayHelloWithArgs) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("FooSayHelloWithArgs")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		case 1:
			p.NewMessage = prot.UnpackString()
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes FooSayHelloWithArgs objects.
func (p *FooSayHelloWithArgs) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("FooSayHelloWithArgs")
	prot.PackString("newMessage", 1, string(p.NewMessage))
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// FooSayHelloWithResult is a frual serializable object.
type FooSayHelloWithResult struct {
	Success *string
}

// NewFooSayHelloWithResult constructs a FooSayHelloWithResult.
func NewFooSayHelloWithResult() *FooSayHelloWithResult {
	return &FooSayHelloWithResult{
		// TODO: default values

	}
}

// Unpack deserializes FooSayHelloWithResult objects.
func (p *FooSayHelloWithResult) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("FooSayHelloWithResult")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		case 0:
			v := prot.UnpackString()
			p.Success = &v
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes FooSayHelloWithResult objects.
func (p *FooSayHelloWithResult) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("FooSayHelloWithResult")
	if p.Success != nil {
		prot.PackString("success", 0, string(*p.Success))
	}
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// FooWhatDoYouSayArgs is a frual serializable object.
type FooWhatDoYouSayArgs struct {
	MessageArgs string
}

// NewFooWhatDoYouSayArgs constructs a FooWhatDoYouSayArgs.
func NewFooWhatDoYouSayArgs() *FooWhatDoYouSayArgs {
	return &FooWhatDoYouSayArgs{
		// TODO: default values

	}
}

// Unpack deserializes FooWhatDoYouSayArgs objects.
func (p *FooWhatDoYouSayArgs) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("FooWhatDoYouSayArgs")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		case 1:
			p.MessageArgs = prot.UnpackString()
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes FooWhatDoYouSayArgs objects.
func (p *FooWhatDoYouSayArgs) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("FooWhatDoYouSayArgs")
	prot.PackString("messageArgs", 1, string(p.MessageArgs))
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// FooWhatDoYouSayResult is a frual serializable object.
type FooWhatDoYouSayResult struct {
	Success *string
}

// NewFooWhatDoYouSayResult constructs a FooWhatDoYouSayResult.
func NewFooWhatDoYouSayResult() *FooWhatDoYouSayResult {
	return &FooWhatDoYouSayResult{
		// TODO: default values

	}
}

// Unpack deserializes FooWhatDoYouSayResult objects.
func (p *FooWhatDoYouSayResult) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("FooWhatDoYouSayResult")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		case 0:
			v := prot.UnpackString()
			p.Success = &v
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes FooWhatDoYouSayResult objects.
func (p *FooWhatDoYouSayResult) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("FooWhatDoYouSayResult")
	if p.Success != nil {
		prot.PackString("success", 0, string(*p.Success))
	}
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// FooSayAgainArgs is a frual serializable object.
type FooSayAgainArgs struct {
	MessageResult string
}

// NewFooSayAgainArgs constructs a FooSayAgainArgs.
func NewFooSayAgainArgs() *FooSayAgainArgs {
	return &FooSayAgainArgs{
		// TODO: default values

	}
}

// Unpack deserializes FooSayAgainArgs objects.
func (p *FooSayAgainArgs) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("FooSayAgainArgs")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		case 1:
			p.MessageResult = prot.UnpackString()
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes FooSayAgainArgs objects.
func (p *FooSayAgainArgs) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("FooSayAgainArgs")
	prot.PackString("messageResult", 1, string(p.MessageResult))
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// FooSayAgainResult is a frual serializable object.
type FooSayAgainResult struct {
	Success *string
}

// NewFooSayAgainResult constructs a FooSayAgainResult.
func NewFooSayAgainResult() *FooSayAgainResult {
	return &FooSayAgainResult{
		// TODO: default values

	}
}

// Unpack deserializes FooSayAgainResult objects.
func (p *FooSayAgainResult) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("FooSayAgainResult")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		case 0:
			v := prot.UnpackString()
			p.Success = &v
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes FooSayAgainResult objects.
func (p *FooSayAgainResult) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("FooSayAgainResult")
	if p.Success != nil {
		prot.PackString("success", 0, string(*p.Success))
	}
	prot.PackFieldStop()
	prot.PackStructEnd()
}
