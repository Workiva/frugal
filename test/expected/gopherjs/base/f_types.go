// Autogenerated by Frugal Compiler (2.23.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package base

import (
	"github.com/Workiva/frugal/lib/gopherjs/frugal"
)

// ConstI32FromBase is a constant.
const ConstI32FromBase = 582

// BaseHealthCondition is an enum.
type BaseHealthCondition int64

// BaseHealthCondition values.
const (
	BaseHealthConditionPASS    BaseHealthCondition = 1
	BaseHealthConditionWARN    BaseHealthCondition = 2
	BaseHealthConditionFAIL    BaseHealthCondition = 3
	BaseHealthConditionUNKNOWN BaseHealthCondition = 4
)

// Thing is a frual serializable object.
type Thing struct {
	AnID    int32
	AString string
}

// NewThing constructs a Thing.
func NewThing() *Thing {
	return &Thing{
		// TODO: default values

	}
}

// Unpack deserializes thing objects.
func (p *Thing) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("thing")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		case 1:
			p.AnID = prot.UnpackI32()
		case 2:
			p.AString = prot.UnpackString()
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes thing objects.
func (p *Thing) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("thing")
	prot.PackI32("an_id", 1, int32(p.AnID))
	prot.PackString("a_string", 2, string(p.AString))
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// NestedThing is a frual serializable object.
type NestedThing struct {
	Things []*Thing
}

// NewNestedThing constructs a NestedThing.
func NewNestedThing() *NestedThing {
	return &NestedThing{
		// TODO: default values

	}
}

// Unpack deserializes nested_thing objects.
func (p *NestedThing) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("nested_thing")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		case 1:
			size := prot.UnpackListBegin()
			if size > 0 {
				p.Things = make([]*Thing, size)
				for i := 0; i < size; i++ {
					(p.Things)[i] = NewThing()
					(p.Things)[i].Unpack(prot)
				}
			}
			prot.UnpackListEnd()
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes nested_thing objects.
func (p *NestedThing) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("nested_thing")
	prot.PackListBegin("things", 1, frugal.STRUCT, len(p.Things))
	for _, v := range p.Things {
		prot.PackFieldBegin("", frugal.STRUCT, -1)
		v.Pack(prot)
		prot.PackFieldEnd(-1)
	}
	prot.PackListEnd(1)
	prot.PackFieldStop()
	prot.PackStructEnd()
}

// APIException is a frual serializable object.
type APIException struct {
}

// NewAPIException constructs a APIException.
func NewAPIException() *APIException {
	return &APIException{
		// TODO: default values

	}
}

// Unpack deserializes api_exception objects.
func (p *APIException) Unpack(prot frugal.Protocol) {
	prot.UnpackStructBegin("api_exception")
	for typeID, id := prot.UnpackFieldBegin(); typeID != frugal.STOP; typeID, id = prot.UnpackFieldBegin() {
		switch id {
		default:
			prot.Skip(typeID)
		}
		prot.UnpackFieldEnd()
	}
	prot.UnpackStructEnd()
}

// Pack serializes api_exception objects.
func (p *APIException) Pack(prot frugal.Protocol) {
	prot.PackStructBegin("api_exception")
	prot.PackFieldStop()
	prot.PackStructEnd()
}

func (p *APIException) Error() string {
	return "TODO: generate errorz"
}
