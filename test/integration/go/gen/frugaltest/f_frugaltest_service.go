// Autogenerated by Frugal Compiler (1.0.5)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package frugaltest

import (
	"bytes"
	"fmt"
	"log"
	"sync"
	"time"

	"git.apache.org/thrift.git/lib/go/thrift"
	"github.com/Workiva/frugal/lib/go"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

type FFrugalTest interface {
	TestVoid(ctx *frugal.FContext) (err error)
	TestString(ctx *frugal.FContext, thing string) (r string, err error)
	TestBool(ctx *frugal.FContext, thing bool) (r bool, err error)
	TestByte(ctx *frugal.FContext, thing int8) (r int8, err error)
	TestI32(ctx *frugal.FContext, thing int32) (r int32, err error)
	TestI64(ctx *frugal.FContext, thing int64) (r int64, err error)
	TestDouble(ctx *frugal.FContext, thing float64) (r float64, err error)
	TestBinary(ctx *frugal.FContext, thing []byte) (r []byte, err error)
	TestStruct(ctx *frugal.FContext, thing *Xtruct) (r *Xtruct, err error)
	TestNest(ctx *frugal.FContext, thing *Xtruct2) (r *Xtruct2, err error)
	TestMap(ctx *frugal.FContext, thing map[int32]int32) (r map[int32]int32, err error)
	TestStringMap(ctx *frugal.FContext, thing map[string]string) (r map[string]string, err error)
	TestSet(ctx *frugal.FContext, thing map[int32]bool) (r map[int32]bool, err error)
	TestList(ctx *frugal.FContext, thing []int32) (r []int32, err error)
	TestEnum(ctx *frugal.FContext, thing Numberz) (r Numberz, err error)
	TestTypedef(ctx *frugal.FContext, thing UserId) (r UserId, err error)
	TestMapMap(ctx *frugal.FContext, hello int32) (r map[int32]map[int32]int32, err error)
	TestInsanity(ctx *frugal.FContext, argument *Insanity) (r map[UserId]map[Numberz]*Insanity, err error)
	TestMulti(ctx *frugal.FContext, arg0 int8, arg1 int32, arg2 int64, arg3 map[int16]string, arg4 Numberz, arg5 UserId) (r *Xtruct, err error)
	TestException(ctx *frugal.FContext, arg string) (err error)
	TestMultiException(ctx *frugal.FContext, arg0 string, arg1 string) (r *Xtruct, err error)
	TestOneway(ctx *frugal.FContext, secondsToSleep int32) (err error)
}

type FFrugalTestClient struct {
	transport       frugal.FTransport
	protocolFactory *frugal.FProtocolFactory
	oprot           *frugal.FProtocol
	mu              sync.Mutex
}

func NewFFrugalTestClient(t frugal.FTransport, p *frugal.FProtocolFactory) *FFrugalTestClient {
	t.SetRegistry(frugal.NewFClientRegistry())
	return &FFrugalTestClient{
		transport:       t,
		protocolFactory: p,
		oprot:           p.GetProtocol(t),
	}
}

func (f *FFrugalTestClient) TestVoid(ctx *frugal.FContext) (err error) {
	errorC := make(chan error, 1)
	resultC := make(chan struct{}, 1)
	if err = f.transport.Register(ctx, f.recvTestVoidHandler(ctx, resultC, errorC)); err != nil {
		return
	}
	defer f.transport.Unregister(ctx)
	f.mu.Lock()
	if err = f.oprot.WriteRequestHeader(ctx); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageBegin("testVoid", thrift.CALL, 0); err != nil {
		f.mu.Unlock()
		return
	}
	args := FrugalTestTestVoidArgs{}
	if err = args.Write(f.oprot); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageEnd(); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.Flush(); err != nil {
		f.mu.Unlock()
		return
	}
	f.mu.Unlock()

	select {
	case err = <-errorC:
	case <-resultC:
	case <-time.After(ctx.Timeout()):
		err = frugal.ErrTimeout
	case <-f.transport.Closed():
		err = frugal.ErrTransportClosed
	}
	return
}

func (f *FFrugalTestClient) recvTestVoidHandler(ctx *frugal.FContext, resultC chan<- struct{}, errorC chan<- error) frugal.FAsyncCallback {
	return func(tr thrift.TTransport) error {
		iprot := f.protocolFactory.GetProtocol(tr)
		if err := iprot.ReadResponseHeader(ctx); err != nil {
			errorC <- err
			return err
		}
		method, mTypeId, _, err := iprot.ReadMessageBegin()
		if err != nil {
			errorC <- err
			return err
		}
		if method != "testVoid" {
			err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "testVoid failed: wrong method name")
			errorC <- err
			return err
		}
		if mTypeId == thrift.EXCEPTION {
			error0 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
			var error1 thrift.TApplicationException
			error1, err = error0.Read(iprot)
			if err != nil {
				errorC <- err
				return err
			}
			if err = iprot.ReadMessageEnd(); err != nil {
				errorC <- err
				return err
			}
			if error1.TypeId() == frugal.RESPONSE_TOO_LARGE {
				err = thrift.NewTTransportException(frugal.RESPONSE_TOO_LARGE, "response too large for transport")
				errorC <- err
				return nil
			}
			err = error1
			errorC <- err
			return err
		}
		if mTypeId != thrift.REPLY {
			err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "testVoid failed: invalid message type")
			errorC <- err
			return err
		}
		result := FrugalTestTestVoidResult{}
		if err = result.Read(iprot); err != nil {
			errorC <- err
			return err
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			errorC <- err
			return err
		}
		resultC <- struct{}{}
		return nil
	}
}

func (f *FFrugalTestClient) TestString(ctx *frugal.FContext, thing string) (r string, err error) {
	errorC := make(chan error, 1)
	resultC := make(chan string, 1)
	if err = f.transport.Register(ctx, f.recvTestStringHandler(ctx, resultC, errorC)); err != nil {
		return
	}
	defer f.transport.Unregister(ctx)
	f.mu.Lock()
	if err = f.oprot.WriteRequestHeader(ctx); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageBegin("testString", thrift.CALL, 0); err != nil {
		f.mu.Unlock()
		return
	}
	args := FrugalTestTestStringArgs{
		Thing: thing,
	}
	if err = args.Write(f.oprot); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageEnd(); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.Flush(); err != nil {
		f.mu.Unlock()
		return
	}
	f.mu.Unlock()

	select {
	case err = <-errorC:
	case r = <-resultC:
	case <-time.After(ctx.Timeout()):
		err = frugal.ErrTimeout
	case <-f.transport.Closed():
		err = frugal.ErrTransportClosed
	}
	return
}

func (f *FFrugalTestClient) recvTestStringHandler(ctx *frugal.FContext, resultC chan<- string, errorC chan<- error) frugal.FAsyncCallback {
	return func(tr thrift.TTransport) error {
		iprot := f.protocolFactory.GetProtocol(tr)
		if err := iprot.ReadResponseHeader(ctx); err != nil {
			errorC <- err
			return err
		}
		method, mTypeId, _, err := iprot.ReadMessageBegin()
		if err != nil {
			errorC <- err
			return err
		}
		if method != "testString" {
			err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "testString failed: wrong method name")
			errorC <- err
			return err
		}
		if mTypeId == thrift.EXCEPTION {
			error0 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
			var error1 thrift.TApplicationException
			error1, err = error0.Read(iprot)
			if err != nil {
				errorC <- err
				return err
			}
			if err = iprot.ReadMessageEnd(); err != nil {
				errorC <- err
				return err
			}
			if error1.TypeId() == frugal.RESPONSE_TOO_LARGE {
				err = thrift.NewTTransportException(frugal.RESPONSE_TOO_LARGE, "response too large for transport")
				errorC <- err
				return nil
			}
			err = error1
			errorC <- err
			return err
		}
		if mTypeId != thrift.REPLY {
			err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "testString failed: invalid message type")
			errorC <- err
			return err
		}
		result := FrugalTestTestStringResult{}
		if err = result.Read(iprot); err != nil {
			errorC <- err
			return err
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			errorC <- err
			return err
		}
		resultC <- result.GetSuccess()
		return nil
	}
}

func (f *FFrugalTestClient) TestBool(ctx *frugal.FContext, thing bool) (r bool, err error) {
	errorC := make(chan error, 1)
	resultC := make(chan bool, 1)
	if err = f.transport.Register(ctx, f.recvTestBoolHandler(ctx, resultC, errorC)); err != nil {
		return
	}
	defer f.transport.Unregister(ctx)
	f.mu.Lock()
	if err = f.oprot.WriteRequestHeader(ctx); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageBegin("testBool", thrift.CALL, 0); err != nil {
		f.mu.Unlock()
		return
	}
	args := FrugalTestTestBoolArgs{
		Thing: thing,
	}
	if err = args.Write(f.oprot); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageEnd(); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.Flush(); err != nil {
		f.mu.Unlock()
		return
	}
	f.mu.Unlock()

	select {
	case err = <-errorC:
	case r = <-resultC:
	case <-time.After(ctx.Timeout()):
		err = frugal.ErrTimeout
	case <-f.transport.Closed():
		err = frugal.ErrTransportClosed
	}
	return
}

func (f *FFrugalTestClient) recvTestBoolHandler(ctx *frugal.FContext, resultC chan<- bool, errorC chan<- error) frugal.FAsyncCallback {
	return func(tr thrift.TTransport) error {
		iprot := f.protocolFactory.GetProtocol(tr)
		if err := iprot.ReadResponseHeader(ctx); err != nil {
			errorC <- err
			return err
		}
		method, mTypeId, _, err := iprot.ReadMessageBegin()
		if err != nil {
			errorC <- err
			return err
		}
		if method != "testBool" {
			err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "testBool failed: wrong method name")
			errorC <- err
			return err
		}
		if mTypeId == thrift.EXCEPTION {
			error0 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
			var error1 thrift.TApplicationException
			error1, err = error0.Read(iprot)
			if err != nil {
				errorC <- err
				return err
			}
			if err = iprot.ReadMessageEnd(); err != nil {
				errorC <- err
				return err
			}
			if error1.TypeId() == frugal.RESPONSE_TOO_LARGE {
				err = thrift.NewTTransportException(frugal.RESPONSE_TOO_LARGE, "response too large for transport")
				errorC <- err
				return nil
			}
			err = error1
			errorC <- err
			return err
		}
		if mTypeId != thrift.REPLY {
			err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "testBool failed: invalid message type")
			errorC <- err
			return err
		}
		result := FrugalTestTestBoolResult{}
		if err = result.Read(iprot); err != nil {
			errorC <- err
			return err
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			errorC <- err
			return err
		}
		resultC <- result.GetSuccess()
		return nil
	}
}

func (f *FFrugalTestClient) TestByte(ctx *frugal.FContext, thing int8) (r int8, err error) {
	errorC := make(chan error, 1)
	resultC := make(chan int8, 1)
	if err = f.transport.Register(ctx, f.recvTestByteHandler(ctx, resultC, errorC)); err != nil {
		return
	}
	defer f.transport.Unregister(ctx)
	f.mu.Lock()
	if err = f.oprot.WriteRequestHeader(ctx); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageBegin("testByte", thrift.CALL, 0); err != nil {
		f.mu.Unlock()
		return
	}
	args := FrugalTestTestByteArgs{
		Thing: thing,
	}
	if err = args.Write(f.oprot); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageEnd(); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.Flush(); err != nil {
		f.mu.Unlock()
		return
	}
	f.mu.Unlock()

	select {
	case err = <-errorC:
	case r = <-resultC:
	case <-time.After(ctx.Timeout()):
		err = frugal.ErrTimeout
	case <-f.transport.Closed():
		err = frugal.ErrTransportClosed
	}
	return
}

func (f *FFrugalTestClient) recvTestByteHandler(ctx *frugal.FContext, resultC chan<- int8, errorC chan<- error) frugal.FAsyncCallback {
	return func(tr thrift.TTransport) error {
		iprot := f.protocolFactory.GetProtocol(tr)
		if err := iprot.ReadResponseHeader(ctx); err != nil {
			errorC <- err
			return err
		}
		method, mTypeId, _, err := iprot.ReadMessageBegin()
		if err != nil {
			errorC <- err
			return err
		}
		if method != "testByte" {
			err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "testByte failed: wrong method name")
			errorC <- err
			return err
		}
		if mTypeId == thrift.EXCEPTION {
			error0 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
			var error1 thrift.TApplicationException
			error1, err = error0.Read(iprot)
			if err != nil {
				errorC <- err
				return err
			}
			if err = iprot.ReadMessageEnd(); err != nil {
				errorC <- err
				return err
			}
			if error1.TypeId() == frugal.RESPONSE_TOO_LARGE {
				err = thrift.NewTTransportException(frugal.RESPONSE_TOO_LARGE, "response too large for transport")
				errorC <- err
				return nil
			}
			err = error1
			errorC <- err
			return err
		}
		if mTypeId != thrift.REPLY {
			err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "testByte failed: invalid message type")
			errorC <- err
			return err
		}
		result := FrugalTestTestByteResult{}
		if err = result.Read(iprot); err != nil {
			errorC <- err
			return err
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			errorC <- err
			return err
		}
		resultC <- result.GetSuccess()
		return nil
	}
}

func (f *FFrugalTestClient) TestI32(ctx *frugal.FContext, thing int32) (r int32, err error) {
	errorC := make(chan error, 1)
	resultC := make(chan int32, 1)
	if err = f.transport.Register(ctx, f.recvTestI32Handler(ctx, resultC, errorC)); err != nil {
		return
	}
	defer f.transport.Unregister(ctx)
	f.mu.Lock()
	if err = f.oprot.WriteRequestHeader(ctx); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageBegin("testI32", thrift.CALL, 0); err != nil {
		f.mu.Unlock()
		return
	}
	args := FrugalTestTestI32Args{
		Thing: thing,
	}
	if err = args.Write(f.oprot); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageEnd(); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.Flush(); err != nil {
		f.mu.Unlock()
		return
	}
	f.mu.Unlock()

	select {
	case err = <-errorC:
	case r = <-resultC:
	case <-time.After(ctx.Timeout()):
		err = frugal.ErrTimeout
	case <-f.transport.Closed():
		err = frugal.ErrTransportClosed
	}
	return
}

func (f *FFrugalTestClient) recvTestI32Handler(ctx *frugal.FContext, resultC chan<- int32, errorC chan<- error) frugal.FAsyncCallback {
	return func(tr thrift.TTransport) error {
		iprot := f.protocolFactory.GetProtocol(tr)
		if err := iprot.ReadResponseHeader(ctx); err != nil {
			errorC <- err
			return err
		}
		method, mTypeId, _, err := iprot.ReadMessageBegin()
		if err != nil {
			errorC <- err
			return err
		}
		if method != "testI32" {
			err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "testI32 failed: wrong method name")
			errorC <- err
			return err
		}
		if mTypeId == thrift.EXCEPTION {
			error0 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
			var error1 thrift.TApplicationException
			error1, err = error0.Read(iprot)
			if err != nil {
				errorC <- err
				return err
			}
			if err = iprot.ReadMessageEnd(); err != nil {
				errorC <- err
				return err
			}
			if error1.TypeId() == frugal.RESPONSE_TOO_LARGE {
				err = thrift.NewTTransportException(frugal.RESPONSE_TOO_LARGE, "response too large for transport")
				errorC <- err
				return nil
			}
			err = error1
			errorC <- err
			return err
		}
		if mTypeId != thrift.REPLY {
			err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "testI32 failed: invalid message type")
			errorC <- err
			return err
		}
		result := FrugalTestTestI32Result{}
		if err = result.Read(iprot); err != nil {
			errorC <- err
			return err
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			errorC <- err
			return err
		}
		resultC <- result.GetSuccess()
		return nil
	}
}

func (f *FFrugalTestClient) TestI64(ctx *frugal.FContext, thing int64) (r int64, err error) {
	errorC := make(chan error, 1)
	resultC := make(chan int64, 1)
	if err = f.transport.Register(ctx, f.recvTestI64Handler(ctx, resultC, errorC)); err != nil {
		return
	}
	defer f.transport.Unregister(ctx)
	f.mu.Lock()
	if err = f.oprot.WriteRequestHeader(ctx); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageBegin("testI64", thrift.CALL, 0); err != nil {
		f.mu.Unlock()
		return
	}
	args := FrugalTestTestI64Args{
		Thing: thing,
	}
	if err = args.Write(f.oprot); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageEnd(); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.Flush(); err != nil {
		f.mu.Unlock()
		return
	}
	f.mu.Unlock()

	select {
	case err = <-errorC:
	case r = <-resultC:
	case <-time.After(ctx.Timeout()):
		err = frugal.ErrTimeout
	case <-f.transport.Closed():
		err = frugal.ErrTransportClosed
	}
	return
}

func (f *FFrugalTestClient) recvTestI64Handler(ctx *frugal.FContext, resultC chan<- int64, errorC chan<- error) frugal.FAsyncCallback {
	return func(tr thrift.TTransport) error {
		iprot := f.protocolFactory.GetProtocol(tr)
		if err := iprot.ReadResponseHeader(ctx); err != nil {
			errorC <- err
			return err
		}
		method, mTypeId, _, err := iprot.ReadMessageBegin()
		if err != nil {
			errorC <- err
			return err
		}
		if method != "testI64" {
			err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "testI64 failed: wrong method name")
			errorC <- err
			return err
		}
		if mTypeId == thrift.EXCEPTION {
			error0 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
			var error1 thrift.TApplicationException
			error1, err = error0.Read(iprot)
			if err != nil {
				errorC <- err
				return err
			}
			if err = iprot.ReadMessageEnd(); err != nil {
				errorC <- err
				return err
			}
			if error1.TypeId() == frugal.RESPONSE_TOO_LARGE {
				err = thrift.NewTTransportException(frugal.RESPONSE_TOO_LARGE, "response too large for transport")
				errorC <- err
				return nil
			}
			err = error1
			errorC <- err
			return err
		}
		if mTypeId != thrift.REPLY {
			err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "testI64 failed: invalid message type")
			errorC <- err
			return err
		}
		result := FrugalTestTestI64Result{}
		if err = result.Read(iprot); err != nil {
			errorC <- err
			return err
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			errorC <- err
			return err
		}
		resultC <- result.GetSuccess()
		return nil
	}
}

func (f *FFrugalTestClient) TestDouble(ctx *frugal.FContext, thing float64) (r float64, err error) {
	errorC := make(chan error, 1)
	resultC := make(chan float64, 1)
	if err = f.transport.Register(ctx, f.recvTestDoubleHandler(ctx, resultC, errorC)); err != nil {
		return
	}
	defer f.transport.Unregister(ctx)
	f.mu.Lock()
	if err = f.oprot.WriteRequestHeader(ctx); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageBegin("testDouble", thrift.CALL, 0); err != nil {
		f.mu.Unlock()
		return
	}
	args := FrugalTestTestDoubleArgs{
		Thing: thing,
	}
	if err = args.Write(f.oprot); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageEnd(); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.Flush(); err != nil {
		f.mu.Unlock()
		return
	}
	f.mu.Unlock()

	select {
	case err = <-errorC:
	case r = <-resultC:
	case <-time.After(ctx.Timeout()):
		err = frugal.ErrTimeout
	case <-f.transport.Closed():
		err = frugal.ErrTransportClosed
	}
	return
}

func (f *FFrugalTestClient) recvTestDoubleHandler(ctx *frugal.FContext, resultC chan<- float64, errorC chan<- error) frugal.FAsyncCallback {
	return func(tr thrift.TTransport) error {
		iprot := f.protocolFactory.GetProtocol(tr)
		if err := iprot.ReadResponseHeader(ctx); err != nil {
			errorC <- err
			return err
		}
		method, mTypeId, _, err := iprot.ReadMessageBegin()
		if err != nil {
			errorC <- err
			return err
		}
		if method != "testDouble" {
			err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "testDouble failed: wrong method name")
			errorC <- err
			return err
		}
		if mTypeId == thrift.EXCEPTION {
			error0 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
			var error1 thrift.TApplicationException
			error1, err = error0.Read(iprot)
			if err != nil {
				errorC <- err
				return err
			}
			if err = iprot.ReadMessageEnd(); err != nil {
				errorC <- err
				return err
			}
			if error1.TypeId() == frugal.RESPONSE_TOO_LARGE {
				err = thrift.NewTTransportException(frugal.RESPONSE_TOO_LARGE, "response too large for transport")
				errorC <- err
				return nil
			}
			err = error1
			errorC <- err
			return err
		}
		if mTypeId != thrift.REPLY {
			err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "testDouble failed: invalid message type")
			errorC <- err
			return err
		}
		result := FrugalTestTestDoubleResult{}
		if err = result.Read(iprot); err != nil {
			errorC <- err
			return err
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			errorC <- err
			return err
		}
		resultC <- result.GetSuccess()
		return nil
	}
}

func (f *FFrugalTestClient) TestBinary(ctx *frugal.FContext, thing []byte) (r []byte, err error) {
	errorC := make(chan error, 1)
	resultC := make(chan []byte, 1)
	if err = f.transport.Register(ctx, f.recvTestBinaryHandler(ctx, resultC, errorC)); err != nil {
		return
	}
	defer f.transport.Unregister(ctx)
	f.mu.Lock()
	if err = f.oprot.WriteRequestHeader(ctx); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageBegin("testBinary", thrift.CALL, 0); err != nil {
		f.mu.Unlock()
		return
	}
	args := FrugalTestTestBinaryArgs{
		Thing: thing,
	}
	if err = args.Write(f.oprot); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageEnd(); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.Flush(); err != nil {
		f.mu.Unlock()
		return
	}
	f.mu.Unlock()

	select {
	case err = <-errorC:
	case r = <-resultC:
	case <-time.After(ctx.Timeout()):
		err = frugal.ErrTimeout
	case <-f.transport.Closed():
		err = frugal.ErrTransportClosed
	}
	return
}

func (f *FFrugalTestClient) recvTestBinaryHandler(ctx *frugal.FContext, resultC chan<- []byte, errorC chan<- error) frugal.FAsyncCallback {
	return func(tr thrift.TTransport) error {
		iprot := f.protocolFactory.GetProtocol(tr)
		if err := iprot.ReadResponseHeader(ctx); err != nil {
			errorC <- err
			return err
		}
		method, mTypeId, _, err := iprot.ReadMessageBegin()
		if err != nil {
			errorC <- err
			return err
		}
		if method != "testBinary" {
			err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "testBinary failed: wrong method name")
			errorC <- err
			return err
		}
		if mTypeId == thrift.EXCEPTION {
			error0 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
			var error1 thrift.TApplicationException
			error1, err = error0.Read(iprot)
			if err != nil {
				errorC <- err
				return err
			}
			if err = iprot.ReadMessageEnd(); err != nil {
				errorC <- err
				return err
			}
			if error1.TypeId() == frugal.RESPONSE_TOO_LARGE {
				err = thrift.NewTTransportException(frugal.RESPONSE_TOO_LARGE, "response too large for transport")
				errorC <- err
				return nil
			}
			err = error1
			errorC <- err
			return err
		}
		if mTypeId != thrift.REPLY {
			err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "testBinary failed: invalid message type")
			errorC <- err
			return err
		}
		result := FrugalTestTestBinaryResult{}
		if err = result.Read(iprot); err != nil {
			errorC <- err
			return err
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			errorC <- err
			return err
		}
		resultC <- result.GetSuccess()
		return nil
	}
}

func (f *FFrugalTestClient) TestStruct(ctx *frugal.FContext, thing *Xtruct) (r *Xtruct, err error) {
	errorC := make(chan error, 1)
	resultC := make(chan *Xtruct, 1)
	if err = f.transport.Register(ctx, f.recvTestStructHandler(ctx, resultC, errorC)); err != nil {
		return
	}
	defer f.transport.Unregister(ctx)
	f.mu.Lock()
	if err = f.oprot.WriteRequestHeader(ctx); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageBegin("testStruct", thrift.CALL, 0); err != nil {
		f.mu.Unlock()
		return
	}
	args := FrugalTestTestStructArgs{
		Thing: thing,
	}
	if err = args.Write(f.oprot); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageEnd(); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.Flush(); err != nil {
		f.mu.Unlock()
		return
	}
	f.mu.Unlock()

	select {
	case err = <-errorC:
	case r = <-resultC:
	case <-time.After(ctx.Timeout()):
		err = frugal.ErrTimeout
	case <-f.transport.Closed():
		err = frugal.ErrTransportClosed
	}
	return
}

func (f *FFrugalTestClient) recvTestStructHandler(ctx *frugal.FContext, resultC chan<- *Xtruct, errorC chan<- error) frugal.FAsyncCallback {
	return func(tr thrift.TTransport) error {
		iprot := f.protocolFactory.GetProtocol(tr)
		if err := iprot.ReadResponseHeader(ctx); err != nil {
			errorC <- err
			return err
		}
		method, mTypeId, _, err := iprot.ReadMessageBegin()
		if err != nil {
			errorC <- err
			return err
		}
		if method != "testStruct" {
			err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "testStruct failed: wrong method name")
			errorC <- err
			return err
		}
		if mTypeId == thrift.EXCEPTION {
			error0 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
			var error1 thrift.TApplicationException
			error1, err = error0.Read(iprot)
			if err != nil {
				errorC <- err
				return err
			}
			if err = iprot.ReadMessageEnd(); err != nil {
				errorC <- err
				return err
			}
			if error1.TypeId() == frugal.RESPONSE_TOO_LARGE {
				err = thrift.NewTTransportException(frugal.RESPONSE_TOO_LARGE, "response too large for transport")
				errorC <- err
				return nil
			}
			err = error1
			errorC <- err
			return err
		}
		if mTypeId != thrift.REPLY {
			err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "testStruct failed: invalid message type")
			errorC <- err
			return err
		}
		result := FrugalTestTestStructResult{}
		if err = result.Read(iprot); err != nil {
			errorC <- err
			return err
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			errorC <- err
			return err
		}
		resultC <- result.GetSuccess()
		return nil
	}
}

func (f *FFrugalTestClient) TestNest(ctx *frugal.FContext, thing *Xtruct2) (r *Xtruct2, err error) {
	errorC := make(chan error, 1)
	resultC := make(chan *Xtruct2, 1)
	if err = f.transport.Register(ctx, f.recvTestNestHandler(ctx, resultC, errorC)); err != nil {
		return
	}
	defer f.transport.Unregister(ctx)
	f.mu.Lock()
	if err = f.oprot.WriteRequestHeader(ctx); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageBegin("testNest", thrift.CALL, 0); err != nil {
		f.mu.Unlock()
		return
	}
	args := FrugalTestTestNestArgs{
		Thing: thing,
	}
	if err = args.Write(f.oprot); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageEnd(); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.Flush(); err != nil {
		f.mu.Unlock()
		return
	}
	f.mu.Unlock()

	select {
	case err = <-errorC:
	case r = <-resultC:
	case <-time.After(ctx.Timeout()):
		err = frugal.ErrTimeout
	case <-f.transport.Closed():
		err = frugal.ErrTransportClosed
	}
	return
}

func (f *FFrugalTestClient) recvTestNestHandler(ctx *frugal.FContext, resultC chan<- *Xtruct2, errorC chan<- error) frugal.FAsyncCallback {
	return func(tr thrift.TTransport) error {
		iprot := f.protocolFactory.GetProtocol(tr)
		if err := iprot.ReadResponseHeader(ctx); err != nil {
			errorC <- err
			return err
		}
		method, mTypeId, _, err := iprot.ReadMessageBegin()
		if err != nil {
			errorC <- err
			return err
		}
		if method != "testNest" {
			err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "testNest failed: wrong method name")
			errorC <- err
			return err
		}
		if mTypeId == thrift.EXCEPTION {
			error0 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
			var error1 thrift.TApplicationException
			error1, err = error0.Read(iprot)
			if err != nil {
				errorC <- err
				return err
			}
			if err = iprot.ReadMessageEnd(); err != nil {
				errorC <- err
				return err
			}
			if error1.TypeId() == frugal.RESPONSE_TOO_LARGE {
				err = thrift.NewTTransportException(frugal.RESPONSE_TOO_LARGE, "response too large for transport")
				errorC <- err
				return nil
			}
			err = error1
			errorC <- err
			return err
		}
		if mTypeId != thrift.REPLY {
			err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "testNest failed: invalid message type")
			errorC <- err
			return err
		}
		result := FrugalTestTestNestResult{}
		if err = result.Read(iprot); err != nil {
			errorC <- err
			return err
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			errorC <- err
			return err
		}
		resultC <- result.GetSuccess()
		return nil
	}
}

func (f *FFrugalTestClient) TestMap(ctx *frugal.FContext, thing map[int32]int32) (r map[int32]int32, err error) {
	errorC := make(chan error, 1)
	resultC := make(chan map[int32]int32, 1)
	if err = f.transport.Register(ctx, f.recvTestMapHandler(ctx, resultC, errorC)); err != nil {
		return
	}
	defer f.transport.Unregister(ctx)
	f.mu.Lock()
	if err = f.oprot.WriteRequestHeader(ctx); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageBegin("testMap", thrift.CALL, 0); err != nil {
		f.mu.Unlock()
		return
	}
	args := FrugalTestTestMapArgs{
		Thing: thing,
	}
	if err = args.Write(f.oprot); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageEnd(); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.Flush(); err != nil {
		f.mu.Unlock()
		return
	}
	f.mu.Unlock()

	select {
	case err = <-errorC:
	case r = <-resultC:
	case <-time.After(ctx.Timeout()):
		err = frugal.ErrTimeout
	case <-f.transport.Closed():
		err = frugal.ErrTransportClosed
	}
	return
}

func (f *FFrugalTestClient) recvTestMapHandler(ctx *frugal.FContext, resultC chan<- map[int32]int32, errorC chan<- error) frugal.FAsyncCallback {
	return func(tr thrift.TTransport) error {
		iprot := f.protocolFactory.GetProtocol(tr)
		if err := iprot.ReadResponseHeader(ctx); err != nil {
			errorC <- err
			return err
		}
		method, mTypeId, _, err := iprot.ReadMessageBegin()
		if err != nil {
			errorC <- err
			return err
		}
		if method != "testMap" {
			err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "testMap failed: wrong method name")
			errorC <- err
			return err
		}
		if mTypeId == thrift.EXCEPTION {
			error0 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
			var error1 thrift.TApplicationException
			error1, err = error0.Read(iprot)
			if err != nil {
				errorC <- err
				return err
			}
			if err = iprot.ReadMessageEnd(); err != nil {
				errorC <- err
				return err
			}
			if error1.TypeId() == frugal.RESPONSE_TOO_LARGE {
				err = thrift.NewTTransportException(frugal.RESPONSE_TOO_LARGE, "response too large for transport")
				errorC <- err
				return nil
			}
			err = error1
			errorC <- err
			return err
		}
		if mTypeId != thrift.REPLY {
			err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "testMap failed: invalid message type")
			errorC <- err
			return err
		}
		result := FrugalTestTestMapResult{}
		if err = result.Read(iprot); err != nil {
			errorC <- err
			return err
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			errorC <- err
			return err
		}
		resultC <- result.GetSuccess()
		return nil
	}
}

func (f *FFrugalTestClient) TestStringMap(ctx *frugal.FContext, thing map[string]string) (r map[string]string, err error) {
	errorC := make(chan error, 1)
	resultC := make(chan map[string]string, 1)
	if err = f.transport.Register(ctx, f.recvTestStringMapHandler(ctx, resultC, errorC)); err != nil {
		return
	}
	defer f.transport.Unregister(ctx)
	f.mu.Lock()
	if err = f.oprot.WriteRequestHeader(ctx); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageBegin("testStringMap", thrift.CALL, 0); err != nil {
		f.mu.Unlock()
		return
	}
	args := FrugalTestTestStringMapArgs{
		Thing: thing,
	}
	if err = args.Write(f.oprot); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageEnd(); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.Flush(); err != nil {
		f.mu.Unlock()
		return
	}
	f.mu.Unlock()

	select {
	case err = <-errorC:
	case r = <-resultC:
	case <-time.After(ctx.Timeout()):
		err = frugal.ErrTimeout
	case <-f.transport.Closed():
		err = frugal.ErrTransportClosed
	}
	return
}

func (f *FFrugalTestClient) recvTestStringMapHandler(ctx *frugal.FContext, resultC chan<- map[string]string, errorC chan<- error) frugal.FAsyncCallback {
	return func(tr thrift.TTransport) error {
		iprot := f.protocolFactory.GetProtocol(tr)
		if err := iprot.ReadResponseHeader(ctx); err != nil {
			errorC <- err
			return err
		}
		method, mTypeId, _, err := iprot.ReadMessageBegin()
		if err != nil {
			errorC <- err
			return err
		}
		if method != "testStringMap" {
			err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "testStringMap failed: wrong method name")
			errorC <- err
			return err
		}
		if mTypeId == thrift.EXCEPTION {
			error0 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
			var error1 thrift.TApplicationException
			error1, err = error0.Read(iprot)
			if err != nil {
				errorC <- err
				return err
			}
			if err = iprot.ReadMessageEnd(); err != nil {
				errorC <- err
				return err
			}
			if error1.TypeId() == frugal.RESPONSE_TOO_LARGE {
				err = thrift.NewTTransportException(frugal.RESPONSE_TOO_LARGE, "response too large for transport")
				errorC <- err
				return nil
			}
			err = error1
			errorC <- err
			return err
		}
		if mTypeId != thrift.REPLY {
			err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "testStringMap failed: invalid message type")
			errorC <- err
			return err
		}
		result := FrugalTestTestStringMapResult{}
		if err = result.Read(iprot); err != nil {
			errorC <- err
			return err
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			errorC <- err
			return err
		}
		resultC <- result.GetSuccess()
		return nil
	}
}

func (f *FFrugalTestClient) TestSet(ctx *frugal.FContext, thing map[int32]bool) (r map[int32]bool, err error) {
	errorC := make(chan error, 1)
	resultC := make(chan map[int32]bool, 1)
	if err = f.transport.Register(ctx, f.recvTestSetHandler(ctx, resultC, errorC)); err != nil {
		return
	}
	defer f.transport.Unregister(ctx)
	f.mu.Lock()
	if err = f.oprot.WriteRequestHeader(ctx); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageBegin("testSet", thrift.CALL, 0); err != nil {
		f.mu.Unlock()
		return
	}
	args := FrugalTestTestSetArgs{
		Thing: thing,
	}
	if err = args.Write(f.oprot); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageEnd(); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.Flush(); err != nil {
		f.mu.Unlock()
		return
	}
	f.mu.Unlock()

	select {
	case err = <-errorC:
	case r = <-resultC:
	case <-time.After(ctx.Timeout()):
		err = frugal.ErrTimeout
	case <-f.transport.Closed():
		err = frugal.ErrTransportClosed
	}
	return
}

func (f *FFrugalTestClient) recvTestSetHandler(ctx *frugal.FContext, resultC chan<- map[int32]bool, errorC chan<- error) frugal.FAsyncCallback {
	return func(tr thrift.TTransport) error {
		iprot := f.protocolFactory.GetProtocol(tr)
		if err := iprot.ReadResponseHeader(ctx); err != nil {
			errorC <- err
			return err
		}
		method, mTypeId, _, err := iprot.ReadMessageBegin()
		if err != nil {
			errorC <- err
			return err
		}
		if method != "testSet" {
			err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "testSet failed: wrong method name")
			errorC <- err
			return err
		}
		if mTypeId == thrift.EXCEPTION {
			error0 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
			var error1 thrift.TApplicationException
			error1, err = error0.Read(iprot)
			if err != nil {
				errorC <- err
				return err
			}
			if err = iprot.ReadMessageEnd(); err != nil {
				errorC <- err
				return err
			}
			if error1.TypeId() == frugal.RESPONSE_TOO_LARGE {
				err = thrift.NewTTransportException(frugal.RESPONSE_TOO_LARGE, "response too large for transport")
				errorC <- err
				return nil
			}
			err = error1
			errorC <- err
			return err
		}
		if mTypeId != thrift.REPLY {
			err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "testSet failed: invalid message type")
			errorC <- err
			return err
		}
		result := FrugalTestTestSetResult{}
		if err = result.Read(iprot); err != nil {
			errorC <- err
			return err
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			errorC <- err
			return err
		}
		resultC <- result.GetSuccess()
		return nil
	}
}

func (f *FFrugalTestClient) TestList(ctx *frugal.FContext, thing []int32) (r []int32, err error) {
	errorC := make(chan error, 1)
	resultC := make(chan []int32, 1)
	if err = f.transport.Register(ctx, f.recvTestListHandler(ctx, resultC, errorC)); err != nil {
		return
	}
	defer f.transport.Unregister(ctx)
	f.mu.Lock()
	if err = f.oprot.WriteRequestHeader(ctx); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageBegin("testList", thrift.CALL, 0); err != nil {
		f.mu.Unlock()
		return
	}
	args := FrugalTestTestListArgs{
		Thing: thing,
	}
	if err = args.Write(f.oprot); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageEnd(); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.Flush(); err != nil {
		f.mu.Unlock()
		return
	}
	f.mu.Unlock()

	select {
	case err = <-errorC:
	case r = <-resultC:
	case <-time.After(ctx.Timeout()):
		err = frugal.ErrTimeout
	case <-f.transport.Closed():
		err = frugal.ErrTransportClosed
	}
	return
}

func (f *FFrugalTestClient) recvTestListHandler(ctx *frugal.FContext, resultC chan<- []int32, errorC chan<- error) frugal.FAsyncCallback {
	return func(tr thrift.TTransport) error {
		iprot := f.protocolFactory.GetProtocol(tr)
		if err := iprot.ReadResponseHeader(ctx); err != nil {
			errorC <- err
			return err
		}
		method, mTypeId, _, err := iprot.ReadMessageBegin()
		if err != nil {
			errorC <- err
			return err
		}
		if method != "testList" {
			err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "testList failed: wrong method name")
			errorC <- err
			return err
		}
		if mTypeId == thrift.EXCEPTION {
			error0 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
			var error1 thrift.TApplicationException
			error1, err = error0.Read(iprot)
			if err != nil {
				errorC <- err
				return err
			}
			if err = iprot.ReadMessageEnd(); err != nil {
				errorC <- err
				return err
			}
			if error1.TypeId() == frugal.RESPONSE_TOO_LARGE {
				err = thrift.NewTTransportException(frugal.RESPONSE_TOO_LARGE, "response too large for transport")
				errorC <- err
				return nil
			}
			err = error1
			errorC <- err
			return err
		}
		if mTypeId != thrift.REPLY {
			err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "testList failed: invalid message type")
			errorC <- err
			return err
		}
		result := FrugalTestTestListResult{}
		if err = result.Read(iprot); err != nil {
			errorC <- err
			return err
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			errorC <- err
			return err
		}
		resultC <- result.GetSuccess()
		return nil
	}
}

func (f *FFrugalTestClient) TestEnum(ctx *frugal.FContext, thing Numberz) (r Numberz, err error) {
	errorC := make(chan error, 1)
	resultC := make(chan Numberz, 1)
	if err = f.transport.Register(ctx, f.recvTestEnumHandler(ctx, resultC, errorC)); err != nil {
		return
	}
	defer f.transport.Unregister(ctx)
	f.mu.Lock()
	if err = f.oprot.WriteRequestHeader(ctx); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageBegin("testEnum", thrift.CALL, 0); err != nil {
		f.mu.Unlock()
		return
	}
	args := FrugalTestTestEnumArgs{
		Thing: thing,
	}
	if err = args.Write(f.oprot); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageEnd(); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.Flush(); err != nil {
		f.mu.Unlock()
		return
	}
	f.mu.Unlock()

	select {
	case err = <-errorC:
	case r = <-resultC:
	case <-time.After(ctx.Timeout()):
		err = frugal.ErrTimeout
	case <-f.transport.Closed():
		err = frugal.ErrTransportClosed
	}
	return
}

func (f *FFrugalTestClient) recvTestEnumHandler(ctx *frugal.FContext, resultC chan<- Numberz, errorC chan<- error) frugal.FAsyncCallback {
	return func(tr thrift.TTransport) error {
		iprot := f.protocolFactory.GetProtocol(tr)
		if err := iprot.ReadResponseHeader(ctx); err != nil {
			errorC <- err
			return err
		}
		method, mTypeId, _, err := iprot.ReadMessageBegin()
		if err != nil {
			errorC <- err
			return err
		}
		if method != "testEnum" {
			err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "testEnum failed: wrong method name")
			errorC <- err
			return err
		}
		if mTypeId == thrift.EXCEPTION {
			error0 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
			var error1 thrift.TApplicationException
			error1, err = error0.Read(iprot)
			if err != nil {
				errorC <- err
				return err
			}
			if err = iprot.ReadMessageEnd(); err != nil {
				errorC <- err
				return err
			}
			if error1.TypeId() == frugal.RESPONSE_TOO_LARGE {
				err = thrift.NewTTransportException(frugal.RESPONSE_TOO_LARGE, "response too large for transport")
				errorC <- err
				return nil
			}
			err = error1
			errorC <- err
			return err
		}
		if mTypeId != thrift.REPLY {
			err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "testEnum failed: invalid message type")
			errorC <- err
			return err
		}
		result := FrugalTestTestEnumResult{}
		if err = result.Read(iprot); err != nil {
			errorC <- err
			return err
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			errorC <- err
			return err
		}
		resultC <- result.GetSuccess()
		return nil
	}
}

func (f *FFrugalTestClient) TestTypedef(ctx *frugal.FContext, thing UserId) (r UserId, err error) {
	errorC := make(chan error, 1)
	resultC := make(chan UserId, 1)
	if err = f.transport.Register(ctx, f.recvTestTypedefHandler(ctx, resultC, errorC)); err != nil {
		return
	}
	defer f.transport.Unregister(ctx)
	f.mu.Lock()
	if err = f.oprot.WriteRequestHeader(ctx); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageBegin("testTypedef", thrift.CALL, 0); err != nil {
		f.mu.Unlock()
		return
	}
	args := FrugalTestTestTypedefArgs{
		Thing: thing,
	}
	if err = args.Write(f.oprot); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageEnd(); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.Flush(); err != nil {
		f.mu.Unlock()
		return
	}
	f.mu.Unlock()

	select {
	case err = <-errorC:
	case r = <-resultC:
	case <-time.After(ctx.Timeout()):
		err = frugal.ErrTimeout
	case <-f.transport.Closed():
		err = frugal.ErrTransportClosed
	}
	return
}

func (f *FFrugalTestClient) recvTestTypedefHandler(ctx *frugal.FContext, resultC chan<- UserId, errorC chan<- error) frugal.FAsyncCallback {
	return func(tr thrift.TTransport) error {
		iprot := f.protocolFactory.GetProtocol(tr)
		if err := iprot.ReadResponseHeader(ctx); err != nil {
			errorC <- err
			return err
		}
		method, mTypeId, _, err := iprot.ReadMessageBegin()
		if err != nil {
			errorC <- err
			return err
		}
		if method != "testTypedef" {
			err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "testTypedef failed: wrong method name")
			errorC <- err
			return err
		}
		if mTypeId == thrift.EXCEPTION {
			error0 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
			var error1 thrift.TApplicationException
			error1, err = error0.Read(iprot)
			if err != nil {
				errorC <- err
				return err
			}
			if err = iprot.ReadMessageEnd(); err != nil {
				errorC <- err
				return err
			}
			if error1.TypeId() == frugal.RESPONSE_TOO_LARGE {
				err = thrift.NewTTransportException(frugal.RESPONSE_TOO_LARGE, "response too large for transport")
				errorC <- err
				return nil
			}
			err = error1
			errorC <- err
			return err
		}
		if mTypeId != thrift.REPLY {
			err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "testTypedef failed: invalid message type")
			errorC <- err
			return err
		}
		result := FrugalTestTestTypedefResult{}
		if err = result.Read(iprot); err != nil {
			errorC <- err
			return err
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			errorC <- err
			return err
		}
		resultC <- result.GetSuccess()
		return nil
	}
}

func (f *FFrugalTestClient) TestMapMap(ctx *frugal.FContext, hello int32) (r map[int32]map[int32]int32, err error) {
	errorC := make(chan error, 1)
	resultC := make(chan map[int32]map[int32]int32, 1)
	if err = f.transport.Register(ctx, f.recvTestMapMapHandler(ctx, resultC, errorC)); err != nil {
		return
	}
	defer f.transport.Unregister(ctx)
	f.mu.Lock()
	if err = f.oprot.WriteRequestHeader(ctx); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageBegin("testMapMap", thrift.CALL, 0); err != nil {
		f.mu.Unlock()
		return
	}
	args := FrugalTestTestMapMapArgs{
		Hello: hello,
	}
	if err = args.Write(f.oprot); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageEnd(); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.Flush(); err != nil {
		f.mu.Unlock()
		return
	}
	f.mu.Unlock()

	select {
	case err = <-errorC:
	case r = <-resultC:
	case <-time.After(ctx.Timeout()):
		err = frugal.ErrTimeout
	case <-f.transport.Closed():
		err = frugal.ErrTransportClosed
	}
	return
}

func (f *FFrugalTestClient) recvTestMapMapHandler(ctx *frugal.FContext, resultC chan<- map[int32]map[int32]int32, errorC chan<- error) frugal.FAsyncCallback {
	return func(tr thrift.TTransport) error {
		iprot := f.protocolFactory.GetProtocol(tr)
		if err := iprot.ReadResponseHeader(ctx); err != nil {
			errorC <- err
			return err
		}
		method, mTypeId, _, err := iprot.ReadMessageBegin()
		if err != nil {
			errorC <- err
			return err
		}
		if method != "testMapMap" {
			err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "testMapMap failed: wrong method name")
			errorC <- err
			return err
		}
		if mTypeId == thrift.EXCEPTION {
			error0 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
			var error1 thrift.TApplicationException
			error1, err = error0.Read(iprot)
			if err != nil {
				errorC <- err
				return err
			}
			if err = iprot.ReadMessageEnd(); err != nil {
				errorC <- err
				return err
			}
			if error1.TypeId() == frugal.RESPONSE_TOO_LARGE {
				err = thrift.NewTTransportException(frugal.RESPONSE_TOO_LARGE, "response too large for transport")
				errorC <- err
				return nil
			}
			err = error1
			errorC <- err
			return err
		}
		if mTypeId != thrift.REPLY {
			err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "testMapMap failed: invalid message type")
			errorC <- err
			return err
		}
		result := FrugalTestTestMapMapResult{}
		if err = result.Read(iprot); err != nil {
			errorC <- err
			return err
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			errorC <- err
			return err
		}
		resultC <- result.GetSuccess()
		return nil
	}
}

func (f *FFrugalTestClient) TestInsanity(ctx *frugal.FContext, argument *Insanity) (r map[UserId]map[Numberz]*Insanity, err error) {
	errorC := make(chan error, 1)
	resultC := make(chan map[UserId]map[Numberz]*Insanity, 1)
	if err = f.transport.Register(ctx, f.recvTestInsanityHandler(ctx, resultC, errorC)); err != nil {
		return
	}
	defer f.transport.Unregister(ctx)
	f.mu.Lock()
	if err = f.oprot.WriteRequestHeader(ctx); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageBegin("testInsanity", thrift.CALL, 0); err != nil {
		f.mu.Unlock()
		return
	}
	args := FrugalTestTestInsanityArgs{
		Argument: argument,
	}
	if err = args.Write(f.oprot); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageEnd(); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.Flush(); err != nil {
		f.mu.Unlock()
		return
	}
	f.mu.Unlock()

	select {
	case err = <-errorC:
	case r = <-resultC:
	case <-time.After(ctx.Timeout()):
		err = frugal.ErrTimeout
	case <-f.transport.Closed():
		err = frugal.ErrTransportClosed
	}
	return
}

func (f *FFrugalTestClient) recvTestInsanityHandler(ctx *frugal.FContext, resultC chan<- map[UserId]map[Numberz]*Insanity, errorC chan<- error) frugal.FAsyncCallback {
	return func(tr thrift.TTransport) error {
		iprot := f.protocolFactory.GetProtocol(tr)
		if err := iprot.ReadResponseHeader(ctx); err != nil {
			errorC <- err
			return err
		}
		method, mTypeId, _, err := iprot.ReadMessageBegin()
		if err != nil {
			errorC <- err
			return err
		}
		if method != "testInsanity" {
			err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "testInsanity failed: wrong method name")
			errorC <- err
			return err
		}
		if mTypeId == thrift.EXCEPTION {
			error0 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
			var error1 thrift.TApplicationException
			error1, err = error0.Read(iprot)
			if err != nil {
				errorC <- err
				return err
			}
			if err = iprot.ReadMessageEnd(); err != nil {
				errorC <- err
				return err
			}
			if error1.TypeId() == frugal.RESPONSE_TOO_LARGE {
				err = thrift.NewTTransportException(frugal.RESPONSE_TOO_LARGE, "response too large for transport")
				errorC <- err
				return nil
			}
			err = error1
			errorC <- err
			return err
		}
		if mTypeId != thrift.REPLY {
			err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "testInsanity failed: invalid message type")
			errorC <- err
			return err
		}
		result := FrugalTestTestInsanityResult{}
		if err = result.Read(iprot); err != nil {
			errorC <- err
			return err
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			errorC <- err
			return err
		}
		resultC <- result.GetSuccess()
		return nil
	}
}

func (f *FFrugalTestClient) TestMulti(ctx *frugal.FContext, arg0 int8, arg1 int32, arg2 int64, arg3 map[int16]string, arg4 Numberz, arg5 UserId) (r *Xtruct, err error) {
	errorC := make(chan error, 1)
	resultC := make(chan *Xtruct, 1)
	if err = f.transport.Register(ctx, f.recvTestMultiHandler(ctx, resultC, errorC)); err != nil {
		return
	}
	defer f.transport.Unregister(ctx)
	f.mu.Lock()
	if err = f.oprot.WriteRequestHeader(ctx); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageBegin("testMulti", thrift.CALL, 0); err != nil {
		f.mu.Unlock()
		return
	}
	args := FrugalTestTestMultiArgs{
		Arg0: arg0,
		Arg1: arg1,
		Arg2: arg2,
		Arg3: arg3,
		Arg4: arg4,
		Arg5: arg5,
	}
	if err = args.Write(f.oprot); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageEnd(); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.Flush(); err != nil {
		f.mu.Unlock()
		return
	}
	f.mu.Unlock()

	select {
	case err = <-errorC:
	case r = <-resultC:
	case <-time.After(ctx.Timeout()):
		err = frugal.ErrTimeout
	case <-f.transport.Closed():
		err = frugal.ErrTransportClosed
	}
	return
}

func (f *FFrugalTestClient) recvTestMultiHandler(ctx *frugal.FContext, resultC chan<- *Xtruct, errorC chan<- error) frugal.FAsyncCallback {
	return func(tr thrift.TTransport) error {
		iprot := f.protocolFactory.GetProtocol(tr)
		if err := iprot.ReadResponseHeader(ctx); err != nil {
			errorC <- err
			return err
		}
		method, mTypeId, _, err := iprot.ReadMessageBegin()
		if err != nil {
			errorC <- err
			return err
		}
		if method != "testMulti" {
			err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "testMulti failed: wrong method name")
			errorC <- err
			return err
		}
		if mTypeId == thrift.EXCEPTION {
			error0 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
			var error1 thrift.TApplicationException
			error1, err = error0.Read(iprot)
			if err != nil {
				errorC <- err
				return err
			}
			if err = iprot.ReadMessageEnd(); err != nil {
				errorC <- err
				return err
			}
			if error1.TypeId() == frugal.RESPONSE_TOO_LARGE {
				err = thrift.NewTTransportException(frugal.RESPONSE_TOO_LARGE, "response too large for transport")
				errorC <- err
				return nil
			}
			err = error1
			errorC <- err
			return err
		}
		if mTypeId != thrift.REPLY {
			err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "testMulti failed: invalid message type")
			errorC <- err
			return err
		}
		result := FrugalTestTestMultiResult{}
		if err = result.Read(iprot); err != nil {
			errorC <- err
			return err
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			errorC <- err
			return err
		}
		resultC <- result.GetSuccess()
		return nil
	}
}

func (f *FFrugalTestClient) TestException(ctx *frugal.FContext, arg string) (err error) {
	errorC := make(chan error, 1)
	resultC := make(chan struct{}, 1)
	if err = f.transport.Register(ctx, f.recvTestExceptionHandler(ctx, resultC, errorC)); err != nil {
		return
	}
	defer f.transport.Unregister(ctx)
	f.mu.Lock()
	if err = f.oprot.WriteRequestHeader(ctx); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageBegin("testException", thrift.CALL, 0); err != nil {
		f.mu.Unlock()
		return
	}
	args := FrugalTestTestExceptionArgs{
		Arg: arg,
	}
	if err = args.Write(f.oprot); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageEnd(); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.Flush(); err != nil {
		f.mu.Unlock()
		return
	}
	f.mu.Unlock()

	select {
	case err = <-errorC:
	case <-resultC:
	case <-time.After(ctx.Timeout()):
		err = frugal.ErrTimeout
	case <-f.transport.Closed():
		err = frugal.ErrTransportClosed
	}
	return
}

func (f *FFrugalTestClient) recvTestExceptionHandler(ctx *frugal.FContext, resultC chan<- struct{}, errorC chan<- error) frugal.FAsyncCallback {
	return func(tr thrift.TTransport) error {
		iprot := f.protocolFactory.GetProtocol(tr)
		if err := iprot.ReadResponseHeader(ctx); err != nil {
			errorC <- err
			return err
		}
		method, mTypeId, _, err := iprot.ReadMessageBegin()
		if err != nil {
			errorC <- err
			return err
		}
		if method != "testException" {
			err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "testException failed: wrong method name")
			errorC <- err
			return err
		}
		if mTypeId == thrift.EXCEPTION {
			error0 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
			var error1 thrift.TApplicationException
			error1, err = error0.Read(iprot)
			if err != nil {
				errorC <- err
				return err
			}
			if err = iprot.ReadMessageEnd(); err != nil {
				errorC <- err
				return err
			}
			if error1.TypeId() == frugal.RESPONSE_TOO_LARGE {
				err = thrift.NewTTransportException(frugal.RESPONSE_TOO_LARGE, "response too large for transport")
				errorC <- err
				return nil
			}
			err = error1
			errorC <- err
			return err
		}
		if mTypeId != thrift.REPLY {
			err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "testException failed: invalid message type")
			errorC <- err
			return err
		}
		result := FrugalTestTestExceptionResult{}
		if err = result.Read(iprot); err != nil {
			errorC <- err
			return err
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			errorC <- err
			return err
		}
		if result.Err1 != nil {
			errorC <- result.Err1
			return nil
		}
		resultC <- struct{}{}
		return nil
	}
}

func (f *FFrugalTestClient) TestMultiException(ctx *frugal.FContext, arg0 string, arg1 string) (r *Xtruct, err error) {
	errorC := make(chan error, 1)
	resultC := make(chan *Xtruct, 1)
	if err = f.transport.Register(ctx, f.recvTestMultiExceptionHandler(ctx, resultC, errorC)); err != nil {
		return
	}
	defer f.transport.Unregister(ctx)
	f.mu.Lock()
	if err = f.oprot.WriteRequestHeader(ctx); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageBegin("testMultiException", thrift.CALL, 0); err != nil {
		f.mu.Unlock()
		return
	}
	args := FrugalTestTestMultiExceptionArgs{
		Arg0: arg0,
		Arg1: arg1,
	}
	if err = args.Write(f.oprot); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageEnd(); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.Flush(); err != nil {
		f.mu.Unlock()
		return
	}
	f.mu.Unlock()

	select {
	case err = <-errorC:
	case r = <-resultC:
	case <-time.After(ctx.Timeout()):
		err = frugal.ErrTimeout
	case <-f.transport.Closed():
		err = frugal.ErrTransportClosed
	}
	return
}

func (f *FFrugalTestClient) recvTestMultiExceptionHandler(ctx *frugal.FContext, resultC chan<- *Xtruct, errorC chan<- error) frugal.FAsyncCallback {
	return func(tr thrift.TTransport) error {
		iprot := f.protocolFactory.GetProtocol(tr)
		if err := iprot.ReadResponseHeader(ctx); err != nil {
			errorC <- err
			return err
		}
		method, mTypeId, _, err := iprot.ReadMessageBegin()
		if err != nil {
			errorC <- err
			return err
		}
		if method != "testMultiException" {
			err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "testMultiException failed: wrong method name")
			errorC <- err
			return err
		}
		if mTypeId == thrift.EXCEPTION {
			error0 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
			var error1 thrift.TApplicationException
			error1, err = error0.Read(iprot)
			if err != nil {
				errorC <- err
				return err
			}
			if err = iprot.ReadMessageEnd(); err != nil {
				errorC <- err
				return err
			}
			if error1.TypeId() == frugal.RESPONSE_TOO_LARGE {
				err = thrift.NewTTransportException(frugal.RESPONSE_TOO_LARGE, "response too large for transport")
				errorC <- err
				return nil
			}
			err = error1
			errorC <- err
			return err
		}
		if mTypeId != thrift.REPLY {
			err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "testMultiException failed: invalid message type")
			errorC <- err
			return err
		}
		result := FrugalTestTestMultiExceptionResult{}
		if err = result.Read(iprot); err != nil {
			errorC <- err
			return err
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			errorC <- err
			return err
		}
		if result.Err1 != nil {
			errorC <- result.Err1
			return nil
		}
		if result.Err2 != nil {
			errorC <- result.Err2
			return nil
		}
		resultC <- result.GetSuccess()
		return nil
	}
}

func (f *FFrugalTestClient) TestOneway(ctx *frugal.FContext, secondstosleep int32) (err error) {
	f.mu.Lock()
	if err = f.oprot.WriteRequestHeader(ctx); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageBegin("testOneway", thrift.ONEWAY, 0); err != nil {
		f.mu.Unlock()
		return
	}
	args := FrugalTestTestOnewayArgs{
		SecondsToSleep: secondstosleep,
	}
	if err = args.Write(f.oprot); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.WriteMessageEnd(); err != nil {
		f.mu.Unlock()
		return
	}
	if err = f.oprot.Flush(); err != nil {
		f.mu.Unlock()
		return
	}
	f.mu.Unlock()

	return
}

type FFrugalTestProcessor struct {
	processorMap map[string]frugal.FProcessorFunction
	writeMu      *sync.Mutex
	handler      FFrugalTest
}

func NewFFrugalTestProcessor(handler FFrugalTest) *FFrugalTestProcessor {
	writeMu := &sync.Mutex{}
	p := &FFrugalTestProcessor{
		processorMap: make(map[string]frugal.FProcessorFunction),
		writeMu:      writeMu,
		handler:      handler,
	}
	p.AddToProcessorMap("testVoid", &frugaltestFTestVoid{handler: handler, writeMu: p.GetWriteMutex()})
	p.AddToProcessorMap("testString", &frugaltestFTestString{handler: handler, writeMu: p.GetWriteMutex()})
	p.AddToProcessorMap("testBool", &frugaltestFTestBool{handler: handler, writeMu: p.GetWriteMutex()})
	p.AddToProcessorMap("testByte", &frugaltestFTestByte{handler: handler, writeMu: p.GetWriteMutex()})
	p.AddToProcessorMap("testI32", &frugaltestFTestI32{handler: handler, writeMu: p.GetWriteMutex()})
	p.AddToProcessorMap("testI64", &frugaltestFTestI64{handler: handler, writeMu: p.GetWriteMutex()})
	p.AddToProcessorMap("testDouble", &frugaltestFTestDouble{handler: handler, writeMu: p.GetWriteMutex()})
	p.AddToProcessorMap("testBinary", &frugaltestFTestBinary{handler: handler, writeMu: p.GetWriteMutex()})
	p.AddToProcessorMap("testStruct", &frugaltestFTestStruct{handler: handler, writeMu: p.GetWriteMutex()})
	p.AddToProcessorMap("testNest", &frugaltestFTestNest{handler: handler, writeMu: p.GetWriteMutex()})
	p.AddToProcessorMap("testMap", &frugaltestFTestMap{handler: handler, writeMu: p.GetWriteMutex()})
	p.AddToProcessorMap("testStringMap", &frugaltestFTestStringMap{handler: handler, writeMu: p.GetWriteMutex()})
	p.AddToProcessorMap("testSet", &frugaltestFTestSet{handler: handler, writeMu: p.GetWriteMutex()})
	p.AddToProcessorMap("testList", &frugaltestFTestList{handler: handler, writeMu: p.GetWriteMutex()})
	p.AddToProcessorMap("testEnum", &frugaltestFTestEnum{handler: handler, writeMu: p.GetWriteMutex()})
	p.AddToProcessorMap("testTypedef", &frugaltestFTestTypedef{handler: handler, writeMu: p.GetWriteMutex()})
	p.AddToProcessorMap("testMapMap", &frugaltestFTestMapMap{handler: handler, writeMu: p.GetWriteMutex()})
	p.AddToProcessorMap("testInsanity", &frugaltestFTestInsanity{handler: handler, writeMu: p.GetWriteMutex()})
	p.AddToProcessorMap("testMulti", &frugaltestFTestMulti{handler: handler, writeMu: p.GetWriteMutex()})
	p.AddToProcessorMap("testException", &frugaltestFTestException{handler: handler, writeMu: p.GetWriteMutex()})
	p.AddToProcessorMap("testMultiException", &frugaltestFTestMultiException{handler: handler, writeMu: p.GetWriteMutex()})
	p.AddToProcessorMap("testOneway", &frugaltestFTestOneway{handler: handler, writeMu: p.GetWriteMutex()})
	return p
}

func (p *FFrugalTestProcessor) AddToProcessorMap(key string, proc frugal.FProcessorFunction) {
	p.processorMap[key] = proc
}

func (p *FFrugalTestProcessor) GetProcessorFunction(key string) (processor frugal.FProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return
}

func (p *FFrugalTestProcessor) GetWriteMutex() *sync.Mutex {
	return p.writeMu
}

func (p *FFrugalTestProcessor) Process(iprot, oprot *frugal.FProtocol) error {
	ctx, err := iprot.ReadRequestHeader()
	if err != nil {
		return err
	}
	name, _, _, err := iprot.ReadMessageBegin()
	if err != nil {
		return err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		err := processor.Process(ctx, iprot, oprot)
		if err != nil {
			log.Printf("frugal: Error processing request with correlationID %s: %s\n", ctx.CorrelationID(), err.Error())
		}
		return err
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x3 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	p.writeMu.Lock()
	oprot.WriteResponseHeader(ctx)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, 0)
	x3.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	p.writeMu.Unlock()
	return x3
}

type frugaltestFTestVoid struct {
	handler FFrugalTest
	writeMu *sync.Mutex
}

func (p *frugaltestFTestVoid) Process(ctx *frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := FrugalTestTestVoidArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.PROTOCOL_ERROR, "testVoid", err.Error())
		p.writeMu.Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := FrugalTestTestVoidResult{}
	var err2 error
	if err2 = p.handler.TestVoid(ctx); err2 != nil {
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.INTERNAL_ERROR, "testVoid", "Internal error processing testVoid: "+err2.Error())
		p.writeMu.Unlock()
		return err2
	}
	p.writeMu.Lock()
	defer p.writeMu.Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testVoid", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("testVoid", thrift.REPLY, 0); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testVoid", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testVoid", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testVoid", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testVoid", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type frugaltestFTestString struct {
	handler FFrugalTest
	writeMu *sync.Mutex
}

func (p *frugaltestFTestString) Process(ctx *frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := FrugalTestTestStringArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.PROTOCOL_ERROR, "testString", err.Error())
		p.writeMu.Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := FrugalTestTestStringResult{}
	var err2 error
	var retval string
	if retval, err2 = p.handler.TestString(ctx, args.Thing); err2 != nil {
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.INTERNAL_ERROR, "testString", "Internal error processing testString: "+err2.Error())
		p.writeMu.Unlock()
		return err2
	} else {
		result.Success = &retval
	}
	p.writeMu.Lock()
	defer p.writeMu.Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testString", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("testString", thrift.REPLY, 0); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testString", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testString", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testString", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testString", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type frugaltestFTestBool struct {
	handler FFrugalTest
	writeMu *sync.Mutex
}

func (p *frugaltestFTestBool) Process(ctx *frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := FrugalTestTestBoolArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.PROTOCOL_ERROR, "testBool", err.Error())
		p.writeMu.Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := FrugalTestTestBoolResult{}
	var err2 error
	var retval bool
	if retval, err2 = p.handler.TestBool(ctx, args.Thing); err2 != nil {
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.INTERNAL_ERROR, "testBool", "Internal error processing testBool: "+err2.Error())
		p.writeMu.Unlock()
		return err2
	} else {
		result.Success = &retval
	}
	p.writeMu.Lock()
	defer p.writeMu.Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testBool", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("testBool", thrift.REPLY, 0); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testBool", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testBool", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testBool", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testBool", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type frugaltestFTestByte struct {
	handler FFrugalTest
	writeMu *sync.Mutex
}

func (p *frugaltestFTestByte) Process(ctx *frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := FrugalTestTestByteArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.PROTOCOL_ERROR, "testByte", err.Error())
		p.writeMu.Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := FrugalTestTestByteResult{}
	var err2 error
	var retval int8
	if retval, err2 = p.handler.TestByte(ctx, args.Thing); err2 != nil {
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.INTERNAL_ERROR, "testByte", "Internal error processing testByte: "+err2.Error())
		p.writeMu.Unlock()
		return err2
	} else {
		result.Success = &retval
	}
	p.writeMu.Lock()
	defer p.writeMu.Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testByte", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("testByte", thrift.REPLY, 0); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testByte", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testByte", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testByte", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testByte", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type frugaltestFTestI32 struct {
	handler FFrugalTest
	writeMu *sync.Mutex
}

func (p *frugaltestFTestI32) Process(ctx *frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := FrugalTestTestI32Args{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.PROTOCOL_ERROR, "testI32", err.Error())
		p.writeMu.Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := FrugalTestTestI32Result{}
	var err2 error
	var retval int32
	if retval, err2 = p.handler.TestI32(ctx, args.Thing); err2 != nil {
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.INTERNAL_ERROR, "testI32", "Internal error processing testI32: "+err2.Error())
		p.writeMu.Unlock()
		return err2
	} else {
		result.Success = &retval
	}
	p.writeMu.Lock()
	defer p.writeMu.Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testI32", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("testI32", thrift.REPLY, 0); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testI32", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testI32", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testI32", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testI32", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type frugaltestFTestI64 struct {
	handler FFrugalTest
	writeMu *sync.Mutex
}

func (p *frugaltestFTestI64) Process(ctx *frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := FrugalTestTestI64Args{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.PROTOCOL_ERROR, "testI64", err.Error())
		p.writeMu.Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := FrugalTestTestI64Result{}
	var err2 error
	var retval int64
	if retval, err2 = p.handler.TestI64(ctx, args.Thing); err2 != nil {
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.INTERNAL_ERROR, "testI64", "Internal error processing testI64: "+err2.Error())
		p.writeMu.Unlock()
		return err2
	} else {
		result.Success = &retval
	}
	p.writeMu.Lock()
	defer p.writeMu.Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testI64", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("testI64", thrift.REPLY, 0); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testI64", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testI64", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testI64", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testI64", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type frugaltestFTestDouble struct {
	handler FFrugalTest
	writeMu *sync.Mutex
}

func (p *frugaltestFTestDouble) Process(ctx *frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := FrugalTestTestDoubleArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.PROTOCOL_ERROR, "testDouble", err.Error())
		p.writeMu.Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := FrugalTestTestDoubleResult{}
	var err2 error
	var retval float64
	if retval, err2 = p.handler.TestDouble(ctx, args.Thing); err2 != nil {
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.INTERNAL_ERROR, "testDouble", "Internal error processing testDouble: "+err2.Error())
		p.writeMu.Unlock()
		return err2
	} else {
		result.Success = &retval
	}
	p.writeMu.Lock()
	defer p.writeMu.Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testDouble", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("testDouble", thrift.REPLY, 0); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testDouble", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testDouble", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testDouble", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testDouble", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type frugaltestFTestBinary struct {
	handler FFrugalTest
	writeMu *sync.Mutex
}

func (p *frugaltestFTestBinary) Process(ctx *frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := FrugalTestTestBinaryArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.PROTOCOL_ERROR, "testBinary", err.Error())
		p.writeMu.Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := FrugalTestTestBinaryResult{}
	var err2 error
	var retval []byte
	if retval, err2 = p.handler.TestBinary(ctx, args.Thing); err2 != nil {
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.INTERNAL_ERROR, "testBinary", "Internal error processing testBinary: "+err2.Error())
		p.writeMu.Unlock()
		return err2
	} else {
		result.Success = retval
	}
	p.writeMu.Lock()
	defer p.writeMu.Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testBinary", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("testBinary", thrift.REPLY, 0); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testBinary", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testBinary", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testBinary", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testBinary", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type frugaltestFTestStruct struct {
	handler FFrugalTest
	writeMu *sync.Mutex
}

func (p *frugaltestFTestStruct) Process(ctx *frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := FrugalTestTestStructArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.PROTOCOL_ERROR, "testStruct", err.Error())
		p.writeMu.Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := FrugalTestTestStructResult{}
	var err2 error
	var retval *Xtruct
	if retval, err2 = p.handler.TestStruct(ctx, args.Thing); err2 != nil {
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.INTERNAL_ERROR, "testStruct", "Internal error processing testStruct: "+err2.Error())
		p.writeMu.Unlock()
		return err2
	} else {
		result.Success = retval
	}
	p.writeMu.Lock()
	defer p.writeMu.Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testStruct", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("testStruct", thrift.REPLY, 0); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testStruct", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testStruct", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testStruct", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testStruct", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type frugaltestFTestNest struct {
	handler FFrugalTest
	writeMu *sync.Mutex
}

func (p *frugaltestFTestNest) Process(ctx *frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := FrugalTestTestNestArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.PROTOCOL_ERROR, "testNest", err.Error())
		p.writeMu.Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := FrugalTestTestNestResult{}
	var err2 error
	var retval *Xtruct2
	if retval, err2 = p.handler.TestNest(ctx, args.Thing); err2 != nil {
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.INTERNAL_ERROR, "testNest", "Internal error processing testNest: "+err2.Error())
		p.writeMu.Unlock()
		return err2
	} else {
		result.Success = retval
	}
	p.writeMu.Lock()
	defer p.writeMu.Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testNest", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("testNest", thrift.REPLY, 0); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testNest", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testNest", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testNest", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testNest", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type frugaltestFTestMap struct {
	handler FFrugalTest
	writeMu *sync.Mutex
}

func (p *frugaltestFTestMap) Process(ctx *frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := FrugalTestTestMapArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.PROTOCOL_ERROR, "testMap", err.Error())
		p.writeMu.Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := FrugalTestTestMapResult{}
	var err2 error
	var retval map[int32]int32
	if retval, err2 = p.handler.TestMap(ctx, args.Thing); err2 != nil {
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.INTERNAL_ERROR, "testMap", "Internal error processing testMap: "+err2.Error())
		p.writeMu.Unlock()
		return err2
	} else {
		result.Success = retval
	}
	p.writeMu.Lock()
	defer p.writeMu.Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testMap", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("testMap", thrift.REPLY, 0); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testMap", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testMap", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testMap", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testMap", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type frugaltestFTestStringMap struct {
	handler FFrugalTest
	writeMu *sync.Mutex
}

func (p *frugaltestFTestStringMap) Process(ctx *frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := FrugalTestTestStringMapArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.PROTOCOL_ERROR, "testStringMap", err.Error())
		p.writeMu.Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := FrugalTestTestStringMapResult{}
	var err2 error
	var retval map[string]string
	if retval, err2 = p.handler.TestStringMap(ctx, args.Thing); err2 != nil {
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.INTERNAL_ERROR, "testStringMap", "Internal error processing testStringMap: "+err2.Error())
		p.writeMu.Unlock()
		return err2
	} else {
		result.Success = retval
	}
	p.writeMu.Lock()
	defer p.writeMu.Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testStringMap", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("testStringMap", thrift.REPLY, 0); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testStringMap", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testStringMap", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testStringMap", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testStringMap", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type frugaltestFTestSet struct {
	handler FFrugalTest
	writeMu *sync.Mutex
}

func (p *frugaltestFTestSet) Process(ctx *frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := FrugalTestTestSetArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.PROTOCOL_ERROR, "testSet", err.Error())
		p.writeMu.Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := FrugalTestTestSetResult{}
	var err2 error
	var retval map[int32]bool
	if retval, err2 = p.handler.TestSet(ctx, args.Thing); err2 != nil {
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.INTERNAL_ERROR, "testSet", "Internal error processing testSet: "+err2.Error())
		p.writeMu.Unlock()
		return err2
	} else {
		result.Success = retval
	}
	p.writeMu.Lock()
	defer p.writeMu.Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testSet", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("testSet", thrift.REPLY, 0); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testSet", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testSet", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testSet", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testSet", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type frugaltestFTestList struct {
	handler FFrugalTest
	writeMu *sync.Mutex
}

func (p *frugaltestFTestList) Process(ctx *frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := FrugalTestTestListArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.PROTOCOL_ERROR, "testList", err.Error())
		p.writeMu.Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := FrugalTestTestListResult{}
	var err2 error
	var retval []int32
	if retval, err2 = p.handler.TestList(ctx, args.Thing); err2 != nil {
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.INTERNAL_ERROR, "testList", "Internal error processing testList: "+err2.Error())
		p.writeMu.Unlock()
		return err2
	} else {
		result.Success = retval
	}
	p.writeMu.Lock()
	defer p.writeMu.Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testList", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("testList", thrift.REPLY, 0); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testList", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testList", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testList", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testList", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type frugaltestFTestEnum struct {
	handler FFrugalTest
	writeMu *sync.Mutex
}

func (p *frugaltestFTestEnum) Process(ctx *frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := FrugalTestTestEnumArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.PROTOCOL_ERROR, "testEnum", err.Error())
		p.writeMu.Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := FrugalTestTestEnumResult{}
	var err2 error
	var retval Numberz
	if retval, err2 = p.handler.TestEnum(ctx, args.Thing); err2 != nil {
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.INTERNAL_ERROR, "testEnum", "Internal error processing testEnum: "+err2.Error())
		p.writeMu.Unlock()
		return err2
	} else {
		result.Success = retval
	}
	p.writeMu.Lock()
	defer p.writeMu.Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testEnum", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("testEnum", thrift.REPLY, 0); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testEnum", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testEnum", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testEnum", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testEnum", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type frugaltestFTestTypedef struct {
	handler FFrugalTest
	writeMu *sync.Mutex
}

func (p *frugaltestFTestTypedef) Process(ctx *frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := FrugalTestTestTypedefArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.PROTOCOL_ERROR, "testTypedef", err.Error())
		p.writeMu.Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := FrugalTestTestTypedefResult{}
	var err2 error
	var retval UserId
	if retval, err2 = p.handler.TestTypedef(ctx, args.Thing); err2 != nil {
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.INTERNAL_ERROR, "testTypedef", "Internal error processing testTypedef: "+err2.Error())
		p.writeMu.Unlock()
		return err2
	} else {
		result.Success = &retval
	}
	p.writeMu.Lock()
	defer p.writeMu.Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testTypedef", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("testTypedef", thrift.REPLY, 0); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testTypedef", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testTypedef", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testTypedef", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testTypedef", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type frugaltestFTestMapMap struct {
	handler FFrugalTest
	writeMu *sync.Mutex
}

func (p *frugaltestFTestMapMap) Process(ctx *frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := FrugalTestTestMapMapArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.PROTOCOL_ERROR, "testMapMap", err.Error())
		p.writeMu.Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := FrugalTestTestMapMapResult{}
	var err2 error
	var retval map[int32]map[int32]int32
	if retval, err2 = p.handler.TestMapMap(ctx, args.Hello); err2 != nil {
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.INTERNAL_ERROR, "testMapMap", "Internal error processing testMapMap: "+err2.Error())
		p.writeMu.Unlock()
		return err2
	} else {
		result.Success = retval
	}
	p.writeMu.Lock()
	defer p.writeMu.Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testMapMap", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("testMapMap", thrift.REPLY, 0); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testMapMap", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testMapMap", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testMapMap", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testMapMap", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type frugaltestFTestInsanity struct {
	handler FFrugalTest
	writeMu *sync.Mutex
}

func (p *frugaltestFTestInsanity) Process(ctx *frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := FrugalTestTestInsanityArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.PROTOCOL_ERROR, "testInsanity", err.Error())
		p.writeMu.Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := FrugalTestTestInsanityResult{}
	var err2 error
	var retval map[UserId]map[Numberz]*Insanity
	if retval, err2 = p.handler.TestInsanity(ctx, args.Argument); err2 != nil {
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.INTERNAL_ERROR, "testInsanity", "Internal error processing testInsanity: "+err2.Error())
		p.writeMu.Unlock()
		return err2
	} else {
		result.Success = retval
	}
	p.writeMu.Lock()
	defer p.writeMu.Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testInsanity", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("testInsanity", thrift.REPLY, 0); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testInsanity", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testInsanity", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testInsanity", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testInsanity", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type frugaltestFTestMulti struct {
	handler FFrugalTest
	writeMu *sync.Mutex
}

func (p *frugaltestFTestMulti) Process(ctx *frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := FrugalTestTestMultiArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.PROTOCOL_ERROR, "testMulti", err.Error())
		p.writeMu.Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := FrugalTestTestMultiResult{}
	var err2 error
	var retval *Xtruct
	if retval, err2 = p.handler.TestMulti(ctx, args.Arg0, args.Arg1, args.Arg2, args.Arg3, args.Arg4, args.Arg5); err2 != nil {
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.INTERNAL_ERROR, "testMulti", "Internal error processing testMulti: "+err2.Error())
		p.writeMu.Unlock()
		return err2
	} else {
		result.Success = retval
	}
	p.writeMu.Lock()
	defer p.writeMu.Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testMulti", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("testMulti", thrift.REPLY, 0); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testMulti", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testMulti", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testMulti", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testMulti", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type frugaltestFTestException struct {
	handler FFrugalTest
	writeMu *sync.Mutex
}

func (p *frugaltestFTestException) Process(ctx *frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := FrugalTestTestExceptionArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.PROTOCOL_ERROR, "testException", err.Error())
		p.writeMu.Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := FrugalTestTestExceptionResult{}
	var err2 error
	if err2 = p.handler.TestException(ctx, args.Arg); err2 != nil {
		switch v := err2.(type) {
		case *Xception:
			result.Err1 = v
		default:
			p.writeMu.Lock()
			frugaltestWriteApplicationError(ctx, oprot, thrift.INTERNAL_ERROR, "testException", "Internal error processing testException: "+err2.Error())
			p.writeMu.Unlock()
			return err2
		}
	}
	p.writeMu.Lock()
	defer p.writeMu.Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testException", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("testException", thrift.REPLY, 0); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testException", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testException", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testException", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testException", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type frugaltestFTestMultiException struct {
	handler FFrugalTest
	writeMu *sync.Mutex
}

func (p *frugaltestFTestMultiException) Process(ctx *frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := FrugalTestTestMultiExceptionArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		p.writeMu.Lock()
		frugaltestWriteApplicationError(ctx, oprot, thrift.PROTOCOL_ERROR, "testMultiException", err.Error())
		p.writeMu.Unlock()
		return err
	}

	iprot.ReadMessageEnd()
	result := FrugalTestTestMultiExceptionResult{}
	var err2 error
	var retval *Xtruct
	if retval, err2 = p.handler.TestMultiException(ctx, args.Arg0, args.Arg1); err2 != nil {
		switch v := err2.(type) {
		case *Xception:
			result.Err1 = v
		case *Xception2:
			result.Err2 = v
		default:
			p.writeMu.Lock()
			frugaltestWriteApplicationError(ctx, oprot, thrift.INTERNAL_ERROR, "testMultiException", "Internal error processing testMultiException: "+err2.Error())
			p.writeMu.Unlock()
			return err2
		}
	} else {
		result.Success = retval
	}
	p.writeMu.Lock()
	defer p.writeMu.Unlock()
	if err2 = oprot.WriteResponseHeader(ctx); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testMultiException", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageBegin("testMultiException", thrift.REPLY, 0); err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testMultiException", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testMultiException", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testMultiException", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		if err2 == frugal.ErrTooLarge {
			frugaltestWriteApplicationError(ctx, oprot, frugal.RESPONSE_TOO_LARGE, "testMultiException", "response too large: "+err2.Error())
			return nil
		}
		err = err2
	}
	return err
}

type frugaltestFTestOneway struct {
	handler FFrugalTest
	writeMu *sync.Mutex
}

func (p *frugaltestFTestOneway) Process(ctx *frugal.FContext, iprot, oprot *frugal.FProtocol) error {
	args := FrugalTestTestOnewayArgs{}
	var err error
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		return err
	}

	iprot.ReadMessageEnd()
	var err2 error
	if err2 = p.handler.TestOneway(ctx, args.SecondsToSleep); err2 != nil {
		return err2
	}
	return err
}

func frugaltestWriteApplicationError(ctx *frugal.FContext, oprot *frugal.FProtocol, type_ int32, method, message string) {
	x := thrift.NewTApplicationException(type_, message)
	oprot.WriteResponseHeader(ctx)
	oprot.WriteMessageBegin(method, thrift.EXCEPTION, 0)
	x.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
}
