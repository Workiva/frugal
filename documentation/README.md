# What is Frugal?

Frugal is an extension of [Apache Thrift](https://thrift.apache.org/) which
provides additional features and improvements. Conceptually, Frugal is a
superset of Thrift, meaning valid Thrift is also valid Frugal (there are some
caveats to this).

Frugal makes use of several core parts of Thrift, including protocols and
transports. This means most of the components that ship with Thrift "just work"
out of the box. Frugal wraps many of these components to extend their
functionality.

See the [glossary](glossary.md) for definitions of Frugal concepts.

# Why does Frugal exist?

Frugal was created to address many of Thrift's shortcomings without completely
reinventing the wheel. Thrift is a solid, mature RPC framework used widely in
production systems. However, it has several key problems.

## Problems with Thrift

- Head-of-line blocking: a single, slow request will block any following
  requests for a client.

- Out-of-order responses: an out-of-order response puts a Thrift transport in a
  bad state, requiring it to be torn down and reestablished. E.g. if a slow
  request times out at the client, the client issues a subsequent request, and
  a response comes back for the first request, the client blows up.

- Concurrency: a Thrift client cannot be shared between multiple threads of
  execution, requiring each thread to have its own client issuing requests
  sequentially. This, combined with head-of-line blocking, is a major
  performance killer.

- RPC timeouts: Thrift does not provide good facilities for per-request
  timeouts, instead opting for a global transport read timeout.

- Request headers: Thrift does not provide support for request metadata, making
  it difficult to implement things like authentication and authorization.
  Instead, you are required to bake these things into your IDL. The problem
  with this is it puts the onus on service providers rather than allowing an
  API gateway or middleware to perform these functions in a centralized way.

- Middleware: Thrift does not have any support for client or server middleware.
  This means clients must be wrapped to implement interceptor logic and
  middleware code must be duplicated within handler functions. This makes it
  impossible to implement AOP-style logic in a clean, DRY way.

- RPC-only: Thrift has limited support for asynchronous messaging patterns, and
  even asynchronous RPC is largely language-dependent and susceptible to the
  head-of-line blocking and out-of-order response problems.

## Frugal Features

Frugal was built to address these concerns. Below are some of the things it
provides.

- Request multiplexing: client requests are fully multiplexed, allowing them to
  be issued concurrently while simultaneously avoiding the head-of-line
  blocking and out-of-order response problems. This also lays some groundwork
  for asynchronous messaging patterns.

- Thread-safety: clients can be safely shared between multiple threads in which
  requests can be made in parallel.

- Pub/sub: IDL and code-generation extensions for defining pub/sub APIs in a
  type-safe way.

- Request context: a first-class request context object is added to every
  operation which allows defining request/response headers and per-request
  timeouts. By making the context part of the Frugal protocol, headers can be
  introspected or even injected by external middleware. This context could be
  used to send OAuth2 tokens and user-context information, avoiding the need to
  include it everywhere in your IDL and handler logic. Correlation IDs for
  distributed tracing purposes are also built into the request context.

- Middleware: client- and server- side middleware is supported for RPC and
  pub/sub APIs. This allows you to implement interceptor logic around handler
  functions, e.g. for authentication, logging, or retry policies.

# Frugal Architecture

At a high-level, Frugal is organized into several layers as in Figure 1.
The layers highlighted in yellow represent application code that is
written by a user. The portions in red represent code generated by the
Frugal compiler from an interface definition defined in an IDL file. The
layers in orange are portions of Frugal available as library code imported
into your application as a dependency. Lastly, the device layer in blue
represents the physical device transmitting messages.

![Frugal Architecture](./images/architecture/FrugalArchitecture.png)

To understand the Frugal architecture requires understanding how each of
the layers in Figure 1 interact with one another. Letâ€™s figure that out by
discussing each of the layers in turn.

## Transports

The Frugal transport layer provides an abstraction over physical devices.
This allows Frugal to mask device specific details and provide a common
API for upper layers that need to use physical devices. Specifically, the
transport layer handles byte-level communication with the underlying
device. By providing this abstraction, Frugal allows for new devices or
middleware to be supported without any impact to the rest of the Frugal
architecture.

Transports are further organized into composable layers called
a *transport stack*. This functionality allows you to abstract a physical
device using a particular transport, then wrap that abstraction with
another logical transport layer such as buffering or encryption, without
changing the interface to transport consumers. Furthermore, the
application is free to select or change the transport stack at compile
time or run time, allowing you to define a flexible transport stack
suitable for different needs.

## Protocols

Protocols provide the means for serializing data types into byte streams
for use by transports. Frugal does not support every type in every
language. Rather, it supports a basic type system that can be converted
into representations in each language. Any valid Frugal protocol
implementation must be capable of reading and writing all types defined by
the Frugal type system (specified by the Frugal interface definition
language, or IDL).

The protocol layer sits on top of a transport stack and has the
responsibility of serializing language specific data types into
language-agnostic byte streams capable of being transmitted using
a transport stack. The client and server are required to use the same
serialization protocol for proper communication.

## The IDL and Compiler

The IDL is designed to make describing an applications data types and
interfaces language independent. This language independent representation
is then used by the Frugal compiler to generate language specific
implementations of the data types and interfaces for use by a user
application.

![Frugal Compiler](./images/architecture/IDLCompiler.png)

### User-Defined Types

While protocols are responsible for serializing at the individual data
type level, the IDL provides support for user-defined data types, structs,
and interfaces, allowing for cross-language serialization of rich
structured data and interfaces. The Frugal compiler uses the IDL to
generate code that automates the serialization of these more complex data
structures using particular protocols.

### Service Stubs

The compiler is also responsible for generating service stubs used by
clients and servers to fulfill any interfaces defined by the IDL. This
provides Frugal users support for cross language RPC. The service stubs
can be divided into two parts: client and server.

#### Client Stubs

The client stub acts as a proxy for the remote service. The client process
calls the proxy to interact with the service and the proxy handles
communication with the underlying protocol and transport. The protocol and
transport are responsible for serializing the messages and receiving back
the results.

#### Server Stubs

The server stub uses the protocol and transport stack to deserialize
incoming method calls, providing hooks into user-defined code for
processing messages as they arrive. The result of these method calls are
then serialized again using the same protocol and transport stack and
delivered back to the client.

The user-defined code is responsible for implementing the service
interface. This code is called by the generated service processor for each
incoming request.

The full request-response life cycle is shown in Figure 3.

![Frugal Compiler](./images/architecture/RPC.png)
