#
# Autogenerated by Frugal Compiler (1.3.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from threading import Lock

from thrift.Thrift import TApplicationException
from thrift.Thrift import TMessageType
from tornado import gen
from tornado.concurrent import Future

from frugal.processor import FBaseProcessor
from frugal.processor import FProcessorFunction
from frugal.registry import FClientRegistry

from base.BaseFoo import basePing_args
from base.BaseFoo import basePing_result


class Iface(object):

    def base_ping(context):
        pass


class Client(Iface):

    def __init__(self, transport, protocol_factory):
        """
        Initialize a Frugal Client

        Args:
            transport: FTransport
            protocl_factory: FProtocolFactory for creating FProtocols
        """

        self._transport = transport
        self._transport.set_registry(FClientRegistry())
        self._protocol_factory = protocol_factory
        self._iprot = self._protocol_factory.get_protocol(self._transport)
        self._oprot = self._protocol_factory.get_protocol(self._transport)
        self._write_lock = Lock()

    def base_ping(self, context):
        """
        base ping

        Args:
            context: FContext
        """
        future = Future()
        self._send_basePing(context, future)
        return future

    def _send_basePing(self, context, future):
        oprot = self._oprot
        self._transport.register(context, self._recv_basePing(context, future))

        with self._write_lock:
            oprot.write_request_headers(context)
            oprot.writeMessageBegin('basePing', TMessageType.CALL, 0)
            args = basePing_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_basePing(self, context, future):
        def basePing_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(context)
            fname, mtype, fid = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = basePing_result()
            result.read(iprot)
            iprot.readMessageEnd()
            future.set_result(None)
        return basePing_callback


class Processor(FBaseProcessor):

    def __init__(self, handler):
        super(Processor, self).__init__()
        self.add_to_processor_map('basePing',
                                  _basePing(handler, self.get_write_lock()))


class _basePing(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, context, iprot, oprot):
        args = basePing_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = basePing_result()
        yield gen.maybe_future(self._handler.base_ping(context))
        with self._lock:
            oprot.writeMessageBegin('basePing', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

