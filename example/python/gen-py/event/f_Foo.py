#
# Autogenerated by Frugal Compiler (1.3.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from frugal.processor import FProcessorFunction
from tornado import gen
from tornado.concurrent import Future
from thrift.Thrift import TApplicationException
from thrift.Thrift import TMessageType

from base import *
from base.ttypes import *

from event.ttypes import *
from event.Foo import *


class Iface(f_BaseFoo.Iface):
    """
    This is a frugal service.  Frugal will generate bindings that include
    a frugal Context for each service call.
    """

    def ping(self, context):
        """
        Ping the server.
        """
        pass

    def blah(self, context, num, Str, event):
        """
        Blah the server.

        Parameters:
            - num
            - Str
            - event
        """
        pass

    def one_way(self, context, id, req):
        """
        oneway methods don't receive a response from the server.

        Parameters:
            - id
            - req
        """
        pass


class Client(f_BaseFoo.Client, Iface):

    def __init__(self, transport, protocol_factory):
        """
        Initialize a Client with a transport and protocol factory creating a
        new FClientRegistry

        Args:
            transport: FTransport
            protocol_factory: FProtocolFactory
        """
        super(Client, self).__init__(transport, protocol_factory)

    def one_way(self, context, id, req):
        """
        oneway methods don't receive a response from the server

        Args:
            context: FContext
            req: dict key values to send (will be converted to JSON string)
        """
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(context)
            oprot.writeMessageBegin("oneWay", TMessageType.ONEWAY, 0)
            args = oneWay_args()
            args.id = id
            args.req = req
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def ping(self, context):
        future = Future()
        self._send_ping(context, future)
        return future

    def blah(self, context, num, Str, event):
        future = Future()
        self._send_blah(context, future, num, Str, event)
        return future

    def _send_ping(self, context, future):
        oprot = self._oprot
        self._transport.register(context, self._recv_ping(context, future))
        with self._write_lock:
            oprot.write_request_headers(context)
            oprot.writeMessageBegin('ping', TMessageType.CALL, 0)
            args = ping_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_ping(self, context, future):
        def ping_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(context)
            fname, mtype, fid = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = ping_result()
            result.read(iprot)
            iprot.readMessageEnd()
            future.set_result(None)
        return ping_callback

    def _send_blah(self, context, future, num, Str, event):
        oprot = self._oprot
        self._transport.register(context, self._recv_blah(context, future))
        with self._write_lock:
            oprot.write_request_headers(context)
            oprot.writeMessageBegin('blah', TMessageType.CALL, 0)
            args = blah_args()
            args.num = num
            args.Str = Str
            args.event = event
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_blah(self, context, future):
        def blah_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(context)
            fname, mtype, fid = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = blah_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            if result.awe is not None:
                future.set_exception(result.awe)
                return
            if result.api is not None:
                future.set_exception(result.api)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT,
                                      "blah failed: unknown result")
            future.set_exception(x)
            raise x
        return blah_callback


class Processor(f_BaseFoo.Processor):

    def __init__(self, handler):
        super(Processor, self).__init__(handler)
        self.add_to_processor_map('ping',
                                  _ping(handler, self.get_write_lock()))
        self.add_to_processor_map('blah',
                                  _blah(handler, self.get_write_lock()))
        self.add_to_processor_map('oneWay',
                                  _oneWay(handler, self.get_write_lock()))


class _ping(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, context, iprot, oprot):
        args = ping_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ping_result()
        yield gen.maybe_future(self._handler.ping(context))
        with self._lock:
            oprot.writeMessageBegin("ping", TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _blah(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, context, iprot, oprot):
        args = blah_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = blah_result()
        try:
            result.success = yield gen.maybe_future(
                self._handler.blah(context, args.num, args.Str, args.event)
            )
        except AwesomeException as awe:
            result.awe = awe
        except api_exception as api:
            result.api = api
        with self._lock:
            oprot.writeMessageBegin("blah", TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _oneWay(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, context, iprot, oprot):
        args = oneWay_args()
        args.read(iprot)
        iprot.readMessageEnd()
        yield gen.maybe_future(self._handler.one_way(context, args.id,
                                                     args.req))

