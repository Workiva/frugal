#
# Autogenerated by Frugal Compiler (1.3.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from tornado import gen
from tornado.concurrent import Future
from thrift.Thrift import TApplicationException
from thrift.Thrift import TMessageType

from base import f_BaseFoo
from base.ttypes import api_exception
from event.ttypes import AwesomeException
from event.Foo import blah_args
from event.Foo import blah_result
from event.Foo import oneWay_args
from event.Foo import ping_args
from event.Foo import ping_result


class Iface(f_BaseFoo.Iface):
    """
    This is a frugal service.  Frugal will generate bindings that include
    a frugal Context for each service call.
    """

    def ping(self, context):
        """
        Ping the server.
        """
        pass

    def blah(self, context, num, Str, event):
        """
        Blah the server.

        Parameters:
            - num
            - Str
            - event
        """
        pass

    def one_way(self, context, id, req):
        """
        oneway methods don't receive a response from the server.

        Parameters:
            - id
            - req
        """
        pass


class Client(f_BaseFoo.Client, Iface):

    def __init__(self, transport, protocol_factory):
        """
        Initialize a Client with a transport and protocol factory creating a
        new FClientRegistry

        Args:
            transport: FTransport
            protocol_factory: FProtocolFactory
        """
        super(Client, self).__init__(transport, protocol_factory)

    def one_way(self, context, id, req):
        """
        oneway methods don't receive a response from the server

        Args:
            context: FContext
            req: dict key values to send (will be converted to JSON string)
        """
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(context)
            oprot.writeMessageBegin("oneWay", TMessageType.ONEWAY, 0)
            args = oneWay_args()
            args.id = id
            args.req = req
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def ping(self, context):
        future = Future()
        self._send_ping(context, future)
        return future

    def blah(self, context, num, Str, event):
        future = Future()
        self._send_blah(context, future, num, Str, event)
        return future

    def _send_ping(self, context, future):
        oprot = self._oprot
        self._transport.register(context, self._recv_ping(context, future))
        with self._write_lock:
            oprot.write_request_headers(context)
            oprot.writeMessageBegin('ping', TMessageType.CALL, 0)
            args = ping_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_ping(self, context, future):
        def ping_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(context)
            fname, mtype, fid = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = ping_result()
            result.read(iprot)
            iprot.readMessageEnd()
            future.set_result(None)
        return ping_callback

    def _send_blah(self, context, future, num, Str, event):
        oprot = self._oprot
        self._transport.register(context, self._recv_blah(context, future))
        with self._write_lock:
            oprot.write_request_headers(context)
            oprot.writeMessageBegin('blah', TMessageType.CALL, 0)
            args = blah_args()
            args.num = num
            args.Str = Str
            args.event = event
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_blah(self, context, future):
        def blah_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(context)
            fname, mtype, fid = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = blah_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            if result.awe is not None:
                future.set_exception(result.awe)
                return
            if result.api is not None:
                future.set_exception(result.api)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT,
                                      "blah failed: unknown result")
            future.set_exception(x)
            raise x
        return blah_callback


class Processor(f_BaseFoo.Processor, Iface):

    def __init__(self, handler):
        super(Processor, self).__init__(handler)
        self.add_to_processor_map('ping', self._process_ping)
        self.add_to_processor_map('blah', self._process_blah)
        self.add_to_processor_map('oneWay', self._process_oneWay)

    @gen.coroutine
    def _process_ping(self, context, iprot, oprot):
        args = ping_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ping_result()
        yield gen.maybe_future(self._handler.ping(context))
        with self.get_write_lock():
            oprot.writeMessageBegin("ping", TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    @gen.coroutine
    def _process_blah(self, context, iprot, oprot):
        args = blah_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = blah_result()
        try:
            result.success = yield gen.maybe_future(
                self._handler.blah(context, args.num, args.Str, args.event)
            )
        except AwesomeException as awe:
            result.awe = awe
        except api_exception as api:
            result.api = api
        with self.get_write_lock():
            oprot.writeMessageBegin("blah", TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    @gen.coroutine
    def _process_oneWay(self, context, iprot, oprot):
        args = oneWay_args()
        args.read(iprot)
        iprot.readMessageEnd()
        yield gen.maybe_future(self._handler.one_way(context, args.id,
                                                     args.req))

