package python

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/Workiva/frugal/compiler/generator"
	"github.com/Workiva/frugal/compiler/globals"
	"github.com/Workiva/frugal/compiler/parser"
)

const (
	lang             = "py"
	defaultOutputDir = "gen-py"
	tab              = "    "
	tabtab           = tab + tab
	tabtabtab        = tab + tab + tab
)

type Generator struct {
	*generator.BaseGenerator
}

func NewGenerator(options map[string]string) generator.LanguageGenerator {
	return &Generator{&generator.BaseGenerator{Options: options}}
}

// TODO Unimplemented methods
func (g *Generator) SetupGenerator(outputDir string) error {
	return nil
}

func (g *Generator) TeardownGenerator() error {
	return nil
}

func (g *Generator) GenerateConstantsContents([]*parser.Constant) error {
	return nil
}

func (g *Generator) GenerateTypeDef(*parser.TypeDef) error {
	return nil
}

func (g *Generator) GenerateEnum(*parser.Enum) error {
	return nil
}
func (g *Generator) GenerateStruct(*parser.Struct) error {
	return nil
}

func (g *Generator) GenerateUnion(*parser.Struct) error {
	return nil
}

func (g *Generator) GenerateException(*parser.Struct) error {
	return nil
}

func (g *Generator) GenerateServiceArgsResults(string, string, []*parser.Struct) error {
	return nil
}

func (g *Generator) GetOutputDir(dir string) string {
	if pkg, ok := g.Frugal.Thrift.Namespace(lang); ok {
		path := generator.GetPackageComponents(pkg)
		dir = filepath.Join(append([]string{dir}, path...)...)
	} else {
		dir = filepath.Join(dir, g.Frugal.Name)
	}
	return dir
}

func (g *Generator) DefaultOutputDir() string {
	return defaultOutputDir
}

func (g *Generator) PostProcess(f *os.File) error { return nil }

func (g *Generator) GenerateDependencies(dir string) error {
	return nil
}

func (g *Generator) GenerateFile(name, outputDir string, fileType generator.FileType) (*os.File, error) {
	switch fileType {
	case generator.PublishFile:
		return g.CreateFile(strings.ToLower(name)+"_publisher", outputDir, lang, false)
	case generator.SubscribeFile:
		return g.CreateFile(strings.ToLower(name)+"_subscriber", outputDir, lang, false)
	case generator.CombinedServiceFile:
		return g.CreateFile("f"+strings.ToLower(name), outputDir, lang, false)
	default:
		return nil, fmt.Errorf("Bad file type for Python generator: %s", fileType)
	}
}

func (g *Generator) GenerateDocStringComment(file *os.File) error {
	comment := fmt.Sprintf(
		"#\n"+
			"# Autogenerated by Frugal Compiler (%s)\n"+
			"#\n"+
			"# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n"+
			"#",
		globals.Version)

	_, err := file.WriteString(comment)
	return err
}

func (g *Generator) GenerateServicePackage(file *os.File, s *parser.Service) error {
	return nil
}

func (g *Generator) GenerateScopePackage(file *os.File, s *parser.Scope) error {
	return nil
}

func (g *Generator) GenerateServiceImports(file *os.File, s *parser.Service) error {
	// TODO
	return nil
}

func (g *Generator) GenerateScopeImports(file *os.File, s *parser.Scope) error {
	imports := "from thrift.Thrift import TMessageType\n"
	_, err := file.WriteString(imports)
	return err
}

func (g *Generator) GenerateConstants(file *os.File, name string) error {
	return nil
}

func (g *Generator) GeneratePublisher(file *os.File, scope *parser.Scope) error {
	publisher := ""
	publisher += fmt.Sprintf("class %sPublisher(object):\n", scope.Name)
	if scope.Comment != nil {
		publisher += g.generateDocString(scope.Comment, tab)
		publisher += "\n"
	}

	publisher += tab + fmt.Sprintf("_DELIMITER = '%s'\n\n", globals.TopicDelimiter)

	publisher += tab + "def __init__(self, provider):\n"
	publisher += g.generateDocString([]string{
		fmt.Sprintf("Create a new %sPublisher.\n", scope.Name),
		"Args:",
		tab + "provider: FScopeProvider",
	}, tabtab)
	publisher += "\n"

	publisher += tabtab + "self._transport, self._protocol = provider.new()\n\n"

	publisher += tab + "def open(self):\n"
	publisher += tabtab + "self._transport.open()\n\n"

	publisher += tab + "def close(self):\n"
	publisher += tabtab + "self._transport.close()\n\n"

	prefix := ""
	for _, op := range scope.Operations {
		publisher += prefix + g.generatePublishMethod(scope, op)
		prefix = "\n\n"
	}

	_, err := file.WriteString(publisher)
	return err
}

func (g *Generator) generatePublishMethod(scope *parser.Scope, op *parser.Operation) string {
	args := ""
	docstr := []string{"Args:", tab + "ctx: FContext"}
	if len(scope.Prefix.Variables) > 0 {
		prefix := ""
		for _, variable := range scope.Prefix.Variables {
			docstr = append(docstr, tab+fmt.Sprintf("%s: string", variable))
			args += prefix + variable
			prefix = ", "
		}
		args += ", "
	}
	docstr = append(docstr, tab+fmt.Sprintf("req: %s", op.Type.Name))
	if op.Comment != nil {
		docstr[0] = "\n" + tabtab + docstr[0]
		docstr = append(op.Comment, docstr...)
	}
	method := tab + fmt.Sprintf("def publish_%s(self, ctx, %sreq):\n", op.Name, args)
	method += g.generateDocString(docstr, tabtab)
	method += "\n"

	method += tabtab + fmt.Sprintf("op = '%s'\n", op.Name)
	method += tabtab + fmt.Sprintf("prefix = %s\n", generatePrefixStringTemplate(scope))
	method += tabtab + fmt.Sprintf("topic = '%%s%s%%s%%s' %% (prefix, self._DELIMITER, op)\n", scope.Name)
	method += tabtab + "oprot = self._protocol\n"
	method += tabtab + "self._transport.lock_topic(topic)\n"
	method += tabtab + "try:\n"
	method += tabtabtab + "oprot.write_request_headers(ctx)\n"
	method += tabtabtab + "oprot.writeMessageBegin(op, TMessageType.CALL, 0)\n"
	method += tabtabtab + "req.write(oprot)\n"
	method += tabtabtab + "oprot.writeMessageEnd()\n"
	method += tabtabtab + "oprot.get_transport().flush()\n"
	method += tabtab + "finally:\n"
	method += tabtabtab + "self._transport.unlock_topic()\n"
	return method
}

func generatePrefixStringTemplate(scope *parser.Scope) string {
	if len(scope.Prefix.Variables) == 0 {
		if scope.Prefix.String == "" {
			return "''"
		}
		return fmt.Sprintf("'%s%s'", scope.Prefix.String, globals.TopicDelimiter)
	}
	template := fmt.Sprintf("'%s%s' %% (", scope.Prefix.Template(), globals.TopicDelimiter)
	prefix := ""
	for _, variable := range scope.Prefix.Variables {
		template += prefix + variable
		prefix = ", "
	}
	template += ")"
	return template
}

func (g *Generator) GenerateSubscriber(file *os.File, scope *parser.Scope) error {
	// TODO
	globals.PrintWarning(fmt.Sprintf("%s: scope subscriber generation is not implemented for Python", scope.Name))
	return nil
}

func (g *Generator) GenerateService(file *os.File, s *parser.Service) error {
	// TODO
	globals.PrintWarning(fmt.Sprintf("%s: service generation is not implemented for Python", s.Name))
	return nil
}

func (g *Generator) generateDocString(lines []string, tab string) string {
	docstr := tab + "\"\"\"\n"
	for _, line := range lines {
		docstr += tab + line + "\n"
	}
	docstr += tab + "\"\"\"\n"
	return docstr
}
