/*
 * Copyright 2017 Workiva
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package gateway

import (
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/Workiva/frugal/compiler/generator"
	"github.com/Workiva/frugal/compiler/generator/golang"
	"github.com/Workiva/frugal/compiler/parser"
)

const (
	lang                = "gateway"
	defaultOutputDir    = "gen-go" // The gateway depends on the generated Go code, must be placed in same package
	serviceSuffix       = "_service_gateway"
	packagePrefixOption = "package_prefix"
	thriftImportOption  = "thrift_import"
	frugalImportOption  = "frugal_import"
	asyncOption         = "async"
	useVendorOption     = "use_vendor"
)

// Generator implements the LanguageGenerator interface for an HTTP Gateway.
type Generator struct {
	*generator.BaseGenerator
	goGenerator *golang.Generator
	typesFile   *os.File
}

// NewGenerator creates a new gateway LanguageGenerator.
func NewGenerator(options map[string]string) generator.LanguageGenerator {
	return &Generator{
		BaseGenerator: &generator.BaseGenerator{Options: options},
		goGenerator:   &golang.Generator{BaseGenerator: &generator.BaseGenerator{Options: options}, DoGenerateConstants: true, TypesFile: nil},
		typesFile:     nil,
	}
}

//
// Generic methods
//

// SetupGenerator performs any setup logic before generation.
// no-op.
func (g *Generator) SetupGenerator(outputDir string) error {
	g.goGenerator.SetFrugal(g.Frugal)

	t, err := g.GenerateFile("", outputDir, generator.TypeFile)
	if err != nil {
		return err
	}
	g.typesFile = t
	if err = g.GenerateDocStringComment(g.typesFile); err != nil {
		return err
	}
	if err = g.GenerateNewline(g.typesFile, 2); err != nil {
		return err
	}
	if err = g.goGenerator.GeneratePackage(g.typesFile); err != nil {
		return err
	}
	if err = g.GenerateNewline(g.typesFile, 2); err != nil {
		return err
	}
	if err = g.GenerateTypesImports(g.typesFile); err != nil {
		return err
	}
	err = g.GenerateNewline(g.typesFile, 2)
	if err != nil {
		return err
	}

	return nil
}

// TeardownGenerator cleanups globals the generator needs, like the types file.
func (g *Generator) TeardownGenerator() error {
	defer g.typesFile.Close()
	return g.PostProcess(g.typesFile)
}

// GenerateDependencies generates any dependencies
// no-op.
func (g *Generator) GenerateDependencies(dir string) error {
	return nil
}

// GenerateFile generates the given FileType.
func (g *Generator) GenerateFile(name, outputDir string, fileType generator.FileType) (*os.File, error) {
	switch fileType {
	case generator.CombinedServiceFile:
		return g.CreateFile(strings.ToLower(name)+serviceSuffix, outputDir, "go", true)
	case generator.TypeFile:
		return g.CreateFile("types_gateway", outputDir, "go", true)
	case generator.ServiceArgsResultsFile:
		return g.CreateFile(strings.ToLower(name), outputDir, "go", true)
	default:
		return nil, fmt.Errorf("Bad file type for golang generator: %s", fileType)
	}
}

// GenerateDocStringComment generates the autogenerated notice.
func (g *Generator) GenerateDocStringComment(file *os.File) error {
	return g.goGenerator.GenerateDocStringComment(file)
}

// GenerateConstants generates any static constants.
// no-op
func (g *Generator) GenerateConstants(file *os.File, name string) error {
	return nil
}

// GetOutputDir returns the output directory for generated files.
func (g *Generator) GetOutputDir(dir string) string {
	if namespace := g.Frugal.Namespace(lang); namespace != nil {
		path := generator.GetPackageComponents(namespace.Value)
		dir = filepath.Join(append([]string{dir}, path...)...)
	} else {
		dir = filepath.Join(dir, g.Frugal.Name)
	}
	return dir
}

// DefaultOutputDir returns the default output directory for generated files.
func (g *Generator) DefaultOutputDir() string {
	return defaultOutputDir
}

// PostProcess file runs gofmt and goimports on the given file.
func (g *Generator) PostProcess(f *os.File) error {
	return g.goGenerator.PostProcess(f)
}

//
// Thrift stuff
//

// GenerateTypesImports generates the necessary Go types imports.
func (g *Generator) GenerateTypesImports(file *os.File) error {
	contents := "import (\n"
	contents += "\t\"bytes\"\n"
	contents += "\t\"fmt\"\n"
	// Enums need these for some reason
	if len(g.Frugal.Enums) > 0 {
		contents += "\t\"database/sql/driver\"\n"
		contents += "\t\"errors\"\n"
	}
	if g.Options[thriftImportOption] != "" {
		contents += "\t\"" + g.Options[thriftImportOption] + "\"\n"
	} else {
		contents += "\t\"git.apache.org/thrift.git/lib/go/thrift\"\n"
	}

	protections := ""
	pkgPrefix := g.Options[packagePrefixOption]
	for _, include := range g.Frugal.Includes {
		imp, err := g.goGenerator.GenerateIncludeImport(include, pkgPrefix)
		if err != nil {
			return err
		}
		contents += imp
		protections += g.goGenerator.GenerateImportProtection(include)
	}

	contents += ")\n\n"
	contents += "// (needed to ensure safety because of naive import list construction.)\n"
	contents += "var _ = thrift.ZERO\n"
	contents += "var _ = fmt.Printf\n"
	contents += "var _ = bytes.Equal\n\n"
	contents += protections
	contents += "var GoUnusedTypesProtection__ int\n"

	// Standard error struct
	contents += "type Error struct {\n"
	contents += "\tResource string `json:\"resource\"`\n" // TODO: can we accurately fill this in? Change API Guidelines?
	contents += "\tField    string `json:\"field\"`\n"
	contents += "\tCode     string `json:\"code\"`\n"
	contents += "}\n"

	contents += "type ErrorResponse struct {\n"
	contents += "\tMessage string `json:\"message\"`\n"
	contents += "\tErrors  []*Error `json:\"errors\"`\n"
	contents += "}\n"

	// Standard success struct
	_, err := file.WriteString(contents)
	return err
}

// GenerateConstantsContents generates constants.
// no-op
func (g *Generator) GenerateConstantsContents(constants []*parser.Constant) error {
	return nil
}

// GenerateTypeDef generates the given typedef.
// no-op
func (g *Generator) GenerateTypeDef(typedef *parser.TypeDef) error {
	return nil
}

// GenerateEnum generates the given enum.
// no-op
func (g *Generator) GenerateEnum(enum *parser.Enum) error {
	return nil
}

// GenerateStruct generates the given struct.
// The HTTP proxy creates mappings betwee
func (g *Generator) GenerateStruct(s *parser.Struct) error {
	contents := ""

	// Check if this struct has JSON mappings
	hasMapping := false
	for _, field := range s.Fields {
		_, found := field.Annotations.Get("http.jsonProperty")
		if found {
			hasMapping = true
			break
		}
	}

	if !hasMapping {
		return nil
	}

	// Generate a struct to handle mappings
	sName := golang.SnakeToCamel(s.Name)
	contents += fmt.Sprintf("// %sJSONMapping maps between JSON annotations and Thrift structs.\n", sName)
	contents += fmt.Sprintf("type %sJSONMapping struct {\n", sName)

	for _, field := range s.Fields {
		// Attach JSON annotations based on IDL annotations
		// If no annotations, use field name
		jsonAnnotation, found := field.Annotations.Get("http.jsonProperty")
		if !found {
			jsonAnnotation = field.Name
		}
		if field.Modifier == parser.Optional {
			jsonAnnotation += ",omitempty"
		}
		annotation := fmt.Sprintf("`json:\"%s\", omitempty`", jsonAnnotation)
		goType := g.goGenerator.GetGoTypeFromThriftTypePtr(field.Type, g.goGenerator.IsPointerField(field))
		contents += fmt.Sprintf("\t%s *%s %s\n", golang.Title(field.Name), goType, annotation)
	}

	contents += "}\n\n"

	_, err := g.typesFile.WriteString(contents)
	return err
}

// GenerateUnion generates the given union.
func (g *Generator) GenerateUnion(union *parser.Struct) error {
	return nil
}

// GenerateException generates the given exception.
func (g *Generator) GenerateException(exception *parser.Struct) error {
	return nil
}

//
// Service-specific methods
//

// GenerateServicePackage generates the package for the given service.
func (g *Generator) GenerateServicePackage(file *os.File, s *parser.Service) error {
	return g.goGenerator.GenerateServicePackage(file, s)
}

// GenerateServiceImports generates necessary imports for the given service.
func (g *Generator) GenerateServiceImports(file *os.File, s *parser.Service) error {
	return g.goGenerator.GenerateServiceImports(file, s)
}

// GenerateService generates the given service.
// TODO: Would using text/template work better?
func (g *Generator) GenerateService(file *os.File, s *parser.Service) error {
	serviceTitle := golang.SnakeToCamel(s.Name)
	contents := ""

	// Generate mappings from JSON structs to Thrift structs
	contents += fmt.Sprintf("// Register%sServiceHandler routes requests to the underlying Frugal client\n", serviceTitle)
	contents += fmt.Sprintf("func Register%sServiceHandler(marshaler gateway.Marshaler, router *gateway.Router, client *F%sClient) error {\n\n", serviceTitle, serviceTitle)

	for _, method := range s.Methods {
		contents += g.generateHandleFunc(method)
	}

	contents += "\treturn nil\n}\n" // close func Register*

	_, err := file.WriteString(contents)
	return err
}

func (g *Generator) generateHandleFunc(method *parser.Method) string {
	var (
		nameTitle = golang.SnakeToCamel(method.Name)
	)
	contents := ""
	path, found := method.Annotations.Get("http.pathTemplate")
	if !found {
		return ""
	}

	// TODO: on error conditions, construct correct response
	contents += "\trouter.HandleFunc("

	// Interpret path template
	contents += strconv.Quote(path)
	contents += ", func(w http.ResponseWriter, req *http.Request) {\n"
	contents += "\t\tf, _ := w.(http.Flusher)\n"

	contents += "\t\tw.Header().Set(\"Content-Type\", marshaler.ContentType())\n"

	// Map request body to Frugal struct
	argument := method.Arguments[0]
	contents += fmt.Sprintf("\t\tvar mapping %sJSONMapping\n", argument.Type.Name)

	// TODO: decoder function can be made top-level and reused?
	contents += "\t\tdecoder := marshaler.NewDecoder(req.Body)\n"
	contents += "\t\tdefer req.Body.Close()\n"
	contents += "\t\terr := decoder.Decode(&mapping)\n"
	contents += "\t\tif err != nil && err != io.EOF {\n"
	contents += "\t\t\tif e, ok := err.(*json.UnmarshalTypeError); ok {\n"
	contents += "\t\t\t\tw.WriteHeader(http.StatusUnprocessableEntity)\n"
	contents += "\t\t\t\tresponse := &ErrorResponse{\n"
	contents += "\t\t\t\t\tMessage: \"Validation failed\",\n"
	contents += "\t\t\t\t\tErrors: []*Error{\n"
	contents += "\t\t\t\t\t	&Error{\n"
	contents += "\t\t\t\t\t		Resource: \"album\",\n" // TODO: extract from path parameter?
	contents += "\t\t\t\t\t		Field:    e.Field,\n"
	contents += "\t\t\t\t\t		Code:     \"invalid\",\n"
	contents += "\t\t\t\t\t	},\n"
	contents += "\t\t\t\t\t},\n"
	contents += "\t\t\t\t}\n"
	contents += "\t\t\t\tbuf, err := marshaler.Marshal(response)\n"
	contents += "\t\t\t\tif err != nil {\n"
	contents += "\t\t\t\t\tbuf = []byte(\"{ \\\"message\\\": \\\"Validation failed\\\" }\")\n"
	contents += "\t\t\t\t}\n"
	contents += "\t\t\t\tw.Write(buf)\n"
	contents += "\t\t\t\tfmt.Println(e)\n"
	contents += "\t\t\t\treturn\n"

	contents += "\t\t\t}\n"
	contents += "\t\t\tw.WriteHeader(http.StatusBadRequest)\n"
	contents += "\t\t\tbuf := []byte(\"{ \\\"message\\\": \\\"Problems parsing JSON\\\" }\")\n"
	contents += "\t\t\tw.Write(buf)\n"
	contents += "\t\t\tfmt.Println(err)\n"
	contents += "\t\t\treturn\n"
	contents += "\t\t}\n"

	contents += "\n\n"

	// Create Thrift payload for calling Frugal client
	contents += fmt.Sprintf("\t\tpayload := &%s{}\n", argument.Type.Name)

	// Map incoming JSON payload to Thrift payload
	parsedStruct := g.Frugal.FindStruct(argument.Type)

	// Map path parameters to struct values
	contents += "\t\ts := reflect.ValueOf(&mapping).Elem()\n"
	contents += "\t\ttypeOfMapping := s.Type()\n"
	contents += "\t\tvars := mux.Vars(req)\n"
	contents += "\t\tfor k, v := range vars {\n"
	contents += "\t\t\tvarField := strings.ToLower(k)\n"
	contents += "\t\t\tfor i := 0; i < s.NumField(); i++ {\n"
	contents += "\t\t\t\tstructField := strings.ToLower(typeOfMapping.Field(i).Name)\n"
	contents += "\t\t\t\tif varField == structField {\n"
	contents += "\t\t\t\t\ts.Field(i).Set(reflect.ValueOf(&v))\n"
	contents += "\t\t\t\t\tcontinue\n"
	contents += "\t\t\t\t}\n"
	contents += "\t\t\t}\n"
	contents += "\t\t}\n"

	// Map query parameters to struct values
	contents += "\t\ts = reflect.ValueOf(&mapping).Elem()\n"
	contents += "\t\ttypeOfMapping = s.Type()\n"
	contents += "\t\tqueries := req.URL.Query()\n"
	contents += "\t\tfor k, v := range queries {\n"
	contents += "\t\t\tvarField := strings.ToLower(k)\n"
	contents += "\t\t\tfor i := 0; i < s.NumField(); i++ {\n"
	contents += "\t\t\t\tstructField := strings.ToLower(typeOfMapping.Field(i).Name)\n"
	contents += "\t\t\t\tif varField == structField {\n"
	contents += "\t\t\t\t\tif len(v) == 1 {\n"
	contents += "\t\t\t\t\t	s.Field(i).Set(reflect.ValueOf(&v[0]))\n"
	contents += "\t\t\t\t\t} else {\n"
	contents += "\t\t\t\t\t	s.Field(i).Set(reflect.ValueOf(&v[0]))\n"
	contents += "\t\t\t\t\t}\n"
	contents += "\t\t\t\t\tcontinue\n"
	contents += "\t\t\t\t}\n"
	contents += "\t\t\t}\n"
	contents += "\t\t}\n"

	// TODO: do we have to handle structs or enums specially?
	for _, field := range parsedStruct.Fields {
		fName := golang.Title(field.Name)
		contents += fmt.Sprintf("\t\tif mapping.%s == nil {\n", fName)
		contents += "\t\t\tw.WriteHeader(http.StatusBadRequest)\n"
		contents += "\t\t\tbuf := []byte(\"{ \\\"message\\\": \\\"Invalid JSON data\\\" }\")\n"
		contents += "\t\t\tw.Write(buf)\n"
		contents += "\t\t\treturn\n"
		contents += "\t\t}\n"
		contents += fmt.Sprintf("\t\tpayload.%s = *mapping.%s\n", fName, fName)
	}

	// Pass payload the Frugal client
	contents += fmt.Sprintf("\t\tresponse, err := client.%s(frugal.NewFContext(\"\"), payload)\n", nameTitle)
	contents += "\t\tif err != nil {\n"
	contents += "\t\t\tgateway.DefaultFrugalErrorHandler(marshaler, w, req, err)\n"
	contents += "\t\t\treturn\n"
	contents += "\t\t}\n"

	// Generate HTTP response from Frugal response
	contents += "\t\tbuf, err := marshaler.Marshal(response)\n"
	contents += "\t\tif err != nil {\n"
	contents += "\t\t\tfmt.Printf(\"Failed to marshal response message %q: %v\", response, err)\n"
	contents += "\t\t\treturn\n"
	contents += "\t\t}\n"

	// Write the response
	contents += "\t\tw.WriteHeader(http.StatusOK)\n"
	contents += "\t\tw.Write(buf)\n"
	contents += "\t\tf.Flush()\n"

	contents += "\t})" // close router.HandleFunc

	// Set the HTTP method
	httpMethod, found := method.Annotations.Get("http.method")
	if found {
		contents += fmt.Sprintf(".Methods(\"%s\")\n", httpMethod)
	} else {
		contents += ".Methods(\"GET\")\n"
	}

	return contents
}

//
// Scope-specific methods
//

// GenerateScopePackage generates the package for the given scope.
func (g *Generator) GenerateScopePackage(*os.File, *parser.Scope) error { return nil }

// GenerateScopeImports generates necessary imports for the given scope.
func (g *Generator) GenerateScopeImports(*os.File, *parser.Scope) error { return nil }

// GeneratePublisher generates the publisher for the given scope.
func (g *Generator) GeneratePublisher(*os.File, *parser.Scope) error { return nil }

// GenerateSubscriber generates the subscriber for the given scope.
func (g *Generator) GenerateSubscriber(*os.File, *parser.Scope) error { return nil }
